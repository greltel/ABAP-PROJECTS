************************************************************************
*   Program name: MM Document Flow                                     *
*   Description :                                                      *
*                                                                      *
*   Created   by: GDRAKOS                                              *
*                                                                      *
************************************************************************
REPORT mm_document_flow NO STANDARD PAGE HEADING LINE-SIZE 255.

*&---------------------------------------------------------------------*
*& CONSTANTS
*&---------------------------------------------------------------------*
CONSTANTS: gc_tree_container TYPE char30     VALUE 'CC_0100_TREE',
           gc_screen_number  TYPE syst-dynnr VALUE '0100',
           gc_screen_status  TYPE gui_status VALUE 'Z_SCREEN_STATUS_0100',
           gc_screen_title   TYPE gui_title  VALUE 'Z_SCREEN_TITLE_0100'.

*&---------------------------------------------------------------------*
*& CLASS DEFINITIONS
*&---------------------------------------------------------------------*
CLASS: lcl_mm_doc_flow DEFINITION DEFERRED,
       lcx_exceptions  DEFINITION DEFERRED,
       lcl_utilities   DEFINITION DEFERRED.

*&---------------------------------------------------------------------*
*& Class LCX_TEXTS
*&---------------------------------------------------------------------*
CLASS lcx_exceptions DEFINITION INHERITING FROM cx_static_check.

  PUBLIC SECTION.

    METHODS:
      constructor IMPORTING text TYPE string,
      get_text REDEFINITION.

  PRIVATE SECTION.

    DATA:
          local_text TYPE string.

ENDCLASS.


*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.

    "PUBLIC METHODS
    METHODS:
      constructor IMPORTING im_document       TYPE ekko-ebeln
                            im_tree_container TYPE char30
                            im_screen_status  TYPE gui_status
                            im_screen_title   TYPE gui_title
                  RAISING   lcx_exceptions,

      process_before_output RAISING   lcx_exceptions,

      process_after_input IMPORTING screen_okcode TYPE syst-ucomm
                          RAISING   lcx_exceptions.

  PROTECTED SECTION.

  PRIVATE SECTION.

    "PRIVATE TYPES
    TYPES:

      BEGIN OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category BASE TYPE char03,
        pr        VALUE 'PR',
        rfq       VALUE 'RFQ',
        qu        VALUE 'QU',
        cn        VALUE 'CN',
        sa        VALUE 'SA',
        po        VALUE 'PO',
        md        VALUE 'MD',
        inv       VALUE 'INV',
        undefined VALUE IS INITIAL,
      END OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category,

      BEGIN OF ty_mm_document_flow,
        document_number              TYPE ebeln,
        document_category            TYPE ty_enum_mm_document_category,
        movement_type                TYPE bwart,
        movement_type_description    TYPE btext,
        transaction_type             TYPE vgabe,
        transaction_type_description TYPE ddtext,
        document_creation_date       TYPE datum,
        document_creation_time       TYPE tims,
      END OF ty_mm_document_flow,

      tt_mm_document_flow TYPE TABLE OF ty_mm_document_flow WITH DEFAULT KEY INITIAL SIZE 0,
      tt_trees_node       TYPE TABLE OF mtreesnode WITH DEFAULT KEY INITIAL SIZE 0.

    "PRIVATE DATA
    DATA:
      lv_document          TYPE ekko-ebeln,
      lv_document_category TYPE ty_enum_mm_document_category,
      lv_tree_container    TYPE char30,
      lv_screen_status     TYPE gui_status,
      lv_screen_title      TYPE gui_title,
      lt_mm_document_flow  TYPE tt_mm_document_flow,
      lt_tree_nodes        TYPE tt_trees_node,
      lo_tree              TYPE REF TO cl_gui_simple_tree.

    "PRIVATE METHODS
    METHODS:
      create_tree IMPORTING im_container_name TYPE char30
                  RAISING   lcx_exceptions,

      determine_document_category RAISING   lcx_exceptions,

      get_mm_document_flow RAISING   lcx_exceptions,

      get_flow_from_pr RAISING   lcx_exceptions,

      get_flow_from_po RAISING   lcx_exceptions,

      get_flow_from_md RAISING   lcx_exceptions,

      get_flow_from_inv RAISING   lcx_exceptions,

      build_node_table RAISING   lcx_exceptions.

    "PRIVATE EVENT METHODS
    METHODS:
      handle_node_double_click  FOR EVENT node_double_click  OF cl_gui_simple_tree IMPORTING node_key.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Class lcl_utilities
*&---------------------------------------------------------------------*
CLASS lcl_utilities DEFINITION CREATE PUBLIC FINAL.

  PUBLIC SECTION.

    CLASS-METHODS:

      dynamic_where_clause IMPORTING im_field                TYPE char5
                                     im_comp                 TYPE ddoption DEFAULT if_fsbp_const_range=>option_equal
                                     im_val                  TYPE string
                                     im_table_name           TYPE tabname
                           RETURNING VALUE(re_select_clause) TYPE hrtb_cond,

      date_external_to_internal IMPORTING im_date                 TYPE string
                                RETURNING VALUE(re_date_internal) TYPE tumls_date,


      convert_to_internal_alpha IMPORTING im_external        TYPE any
                                RETURNING VALUE(re_internal) TYPE string.

  PRIVATE SECTION.

    CLASS-METHODS:

      check_field_exists_in_table IMPORTING im_field         TYPE char5
                                            im_table         TYPE tabname30
                                  RETURNING VALUE(re_exists) TYPE abap_bool.



ENDCLASS.
*&---------------------------------------------------------------------*
*& SELECTION SCREEN DESIGN
*&---------------------------------------------------------------------*

SELECTION-SCREEN: BEGIN OF BLOCK b00 WITH FRAME TITLE title1.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_doc FOR FIELD p_doc.
PARAMETERS : p_doc TYPE ekpo-ebeln OBLIGATORY.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: END OF BLOCK b00.

*&---------------------------------------------------------------------*
*& INITIALIZATION OF SELECTION SCREEN ELEMENTS
*&---------------------------------------------------------------------*
INITIALIZATION.
  PERFORM screen_initialization.

*&---------------------------------------------------------------------*
*& EXECUTABLE CODE
*&---------------------------------------------------------------------*
START-OF-SELECTION.

  TRY.
      DATA(lo_mm_document_flow) = NEW lcl_mm_doc_flow( im_document = p_doc
                                                       im_tree_container = gc_tree_container
                                                       im_screen_status = gc_screen_status
                                                       im_screen_title = gc_screen_title ).
      CALL SCREEN gc_screen_number.
    CATCH lcx_exceptions.
  ENDTRY.

END-OF-SELECTION.

*&---------------------------------------------------------------------*
*& SUBROUTINE CREATION
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Form SCREEN INITIALIZATION
*&---------------------------------------------------------------------*
FORM screen_initialization.

  title1  = 'Purchasing Document Selection'.
  t_doc   = 'MM Document'.

ENDFORM.

*&---------------------------------------------------------------------*
*& CLASS IMPLEMENTATIONS
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow IMPLEMENTATION.

  METHOD constructor.

    CLEAR:me->lv_document_category,me->lv_document.

    me->lv_document = im_document.
    me->lv_tree_container = im_tree_container.
    me->lv_screen_status = im_screen_status.
    me->lv_screen_title = im_screen_title.


    me->determine_document_category( ).
    me->get_mm_document_flow( ).
    me->build_node_table( ).

  ENDMETHOD.

  METHOD process_before_output.

    SET PF-STATUS me->lv_screen_status.
    SET TITLEBAR  me->lv_screen_title.

    me->create_tree( im_container_name = me->lv_tree_container ).

  ENDMETHOD.


  METHOD process_after_input.

    CASE screen_okcode.
      WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
        LEAVE TO SCREEN 0.
    ENDCASE.

  ENDMETHOD.

  METHOD determine_document_category.

    CLEAR:me->lv_document_category.

    "PURCHASE REQUISITION
    SELECT SINGLE @abap_true FROM eban WHERE banfn EQ @me->lv_document AND bstyp EQ 'B' INTO @DATA(lv_exists).

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-pr.
      RETURN.
    ENDIF.

    "REQUEST FOR QUOTATION
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'R' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-rfq.
      RETURN.
    ENDIF.

    "QUOTATION
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'O' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-qu.
      RETURN.
    ENDIF.

    "CONTRACT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'K' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-cn.
      RETURN.
    ENDIF.

    "SCHEDULING AGREEMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'L' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-sa.
      RETURN.
    ENDIF.

    "PURCHASE ORDER
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'F' INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-po.
      RETURN.
    ENDIF.

    "MATERIAL DOCUMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM mkpf WHERE mblnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-md.
      RETURN.
    ENDIF.

    "INVOICE
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM rbkp WHERE belnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-inv.
      RETURN.
    ENDIF.

    "NOT FOUND
    RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Document Not Found'.

  ENDMETHOD.

  METHOD get_mm_document_flow.

    CASE me->lv_document_category.

      WHEN me->mm_document_category-pr.

        me->get_flow_from_pr( ).

      WHEN me->mm_document_category-po.

        me->get_flow_from_po( ).

      WHEN me->mm_document_category-md.

        me->get_flow_from_md( ).

      WHEN me->mm_document_category-inv.

        me->get_flow_from_inv( ).

    ENDCASE.

  ENDMETHOD.

  METHOD get_flow_from_pr.

    "Purchase Requisition
    SELECT SINGLE
      eban~banfn  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time

      FROM eban
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ 'I'
      WHERE eban~banfn EQ @lv_document AND
            eban~bstyp EQ 'B'
      INTO @DATA(ls_pr).

    IF sy-subrc EQ 0 AND ls_pr IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_pr-document_number
                      document_category      = mm_document_category-pr
                      document_creation_date = ls_pr-document_creation_date
                      document_creation_time = ls_pr-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Outline agreement( Contract and Scheduling Agreement )
    SELECT
      DISTINCT ( ekpo~konnr )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time
    FROM ekpo
    INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN eban ON ekpo~banfn EQ eban~banfn
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~banfn EQ @lv_document AND
          ekpo~konnr IS NOT INITIAL
    INTO TABLE @DATA(lt_oa).

    IF sy-subrc EQ 0 AND lt_oa IS NOT INITIAL.

      LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<fs_oa>).

        SELECT SINGLE bstyp FROM ekpo WHERE konnr EQ @<fs_oa>-document_number AND banfn EQ @lv_document INTO @DATA(lv_document_category).

        APPEND VALUE #( document_number      = <fs_oa>-document_number
                      document_category      = COND #( WHEN lv_document_category EQ 'K' THEN mm_document_category-cn
                                                       WHEN lv_document_category EQ 'L' THEN mm_document_category-sa
                                                       ELSE mm_document_category-cn )
                      document_creation_date = <fs_oa>-document_creation_date
                      document_creation_time = <fs_oa>-document_creation_time ) TO lt_mm_document_flow.

        CLEAR:lv_document_category.
      ENDLOOP.

    ENDIF.

    "Purchase Order
    SELECT
    DISTINCT ( ekko~ebeln )  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN eban ON ekpo~banfn EQ eban~banfn
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~banfn EQ @lv_document
    INTO TABLE @DATA(lt_po).

    IF sy-subrc EQ 0 AND lt_po IS NOT INITIAL.
      LOOP AT lt_po ASSIGNING FIELD-SYMBOL(<fs_po>).

        APPEND VALUE #( document_number        = <fs_po>-document_number
                        document_category      = mm_document_category-po
                        document_creation_date = <fs_po>-document_creation_date
                        document_creation_time = <fs_po>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.
    ENDIF.

    "Material Document
    SELECT
     DISTINCT ( ekbe~belnr ) AS document_number,
     ekbe~bwart AS movement_type,
     t156ht~btext AS movement_type_description,
     ekbe~vgabe AS transaction_type,
     ekbe~cpudt AS document_creation_date,
     ekbe~cputm AS document_creation_time

      FROM ekbe
      INNER JOIN @lt_po AS a ON a~document_number EQ ekbe~ebeln
      LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
      WHERE  ekbe~bwart IS NOT INITIAL
      INTO TABLE @DATA(lt_md).

    IF sy-subrc EQ 0 AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "INVOICE
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

   FROM ekbe
   INNER JOIN @lt_po AS a ON a~document_number EQ ekbe~ebeln
   LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
   WHERE ekbe~bwart IS INITIAL
   INTO TABLE @DATA(lt_inv).

    IF sy-subrc EQ 0 AND lt_inv IS NOT INITIAL.

      LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

        APPEND VALUE #( document_number              = <fs_inv>-document_number
                        document_category            = mm_document_category-inv
                        movement_type                = <fs_inv>-movement_type
                        movement_type_description    = <fs_inv>-movement_type_description
                        transaction_type             = <fs_inv>-transaction_type
                        document_creation_date       = <fs_inv>-document_creation_date
                        document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_po.

    DATA(lt_vgabe_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'VGABE' ) )->get_ddic_fixed_values( sy-langu ).
    DATA(lt_bsart_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'BSART' ) )->get_ddic_fixed_values( sy-langu ).

    "Purchase Requisition
    SELECT
      DISTINCT ( eban~banfn )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time

      FROM ekpo
      INNER JOIN eban ON eban~banfn EQ ekpo~banfn
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ 'I'
      WHERE ekpo~ebeln EQ @lv_document AND
            eban~bstyp EQ 'B'
      INTO TABLE @DATA(lt_pr).

    IF sy-subrc EQ 0 AND lt_pr IS NOT INITIAL.

      LOOP AT lt_pr ASSIGNING FIELD-SYMBOL(<fs_pr>).
        APPEND VALUE #( document_number        = <fs_pr>-document_number
                        document_category      = mm_document_category-pr
                        document_creation_date = <fs_pr>-document_creation_date
                        document_creation_time = <fs_pr>-document_creation_time ) TO lt_mm_document_flow.
      ENDLOOP.

    ENDIF.


    "Outline agreement( Contract and Scheduling Agreement )
    SELECT
      DISTINCT ( ekpo~konnr )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time
    FROM ekpo
    INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~ebeln EQ @lv_document AND
          ekpo~konnr IS NOT INITIAL
    INTO TABLE @DATA(lt_oa).

    IF sy-subrc EQ 0 AND lt_oa IS NOT INITIAL.

      LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<ls_oa>).

        SELECT SINGLE bstyp FROM ekko WHERE ebeln EQ @<ls_oa>-document_number INTO @DATA(lv_document_category).

        APPEND VALUE #( document_number      = <ls_oa>-document_number
                      document_category      = COND #( WHEN lv_document_category EQ 'K' THEN mm_document_category-cn
                                                       WHEN lv_document_category EQ 'L' THEN mm_document_category-sa
                                                       ELSE mm_document_category-cn )
                      document_creation_date = <ls_oa>-document_creation_date
                      document_creation_time = <ls_oa>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.



    ENDIF.

    "Purchase Order
    SELECT SINGLE
    ekko~ebeln  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~ebeln EQ @lv_document
    INTO @DATA(ls_po).

    IF sy-subrc EQ 0 AND ls_po IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_po-document_number
                      document_category      = mm_document_category-po
                      document_creation_date = ls_po-document_creation_date
                      document_creation_time = ls_po-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Material Document
    SELECT
     DISTINCT ( ekbe~belnr ) AS document_number,
     ekbe~bwart AS movement_type,
     t156ht~btext AS movement_type_description,
     ekbe~vgabe AS transaction_type,
     a~ddtext AS transaction_type_description,
     ekbe~cpudt AS document_creation_date,
     ekbe~cputm AS document_creation_time

      FROM ekbe
      LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
      LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
      WHERE ebeln EQ @lv_document AND
            ekbe~bwart IS NOT INITIAL
      INTO TABLE @DATA(lt_md).

    IF sy-subrc EQ 0 AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        transaction_type_description = <fs_md>-transaction_type_description
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "INVOICE
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    a~ddtext AS transaction_type_description,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

   FROM ekbe
   LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
   LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
   WHERE ebeln EQ @lv_document AND
         ekbe~bwart IS INITIAL
   INTO TABLE @DATA(lt_inv).

    IF sy-subrc EQ 0 AND lt_inv IS NOT INITIAL.

      LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

        APPEND VALUE #( document_number              = <fs_inv>-document_number
                        document_category            = mm_document_category-inv
                        movement_type                = <fs_inv>-movement_type
                        movement_type_description    = <fs_inv>-movement_type_description
                        transaction_type             = <fs_inv>-transaction_type
                        transaction_type_description = <fs_inv>-transaction_type_description
                        document_creation_date       = <fs_inv>-document_creation_date
                        document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_md.



  ENDMETHOD.


  METHOD get_flow_from_inv.



  ENDMETHOD.

  METHOD build_node_table.

    "ROOT NODE
    APPEND VALUE #( hidden    = space
                    disabled  = space
                    isfolder  = abap_true
                    node_key  = syst-repid
                    text      = |MM Document Flow Of { lv_document ALPHA = OUT } |
                    n_image   =  icon_system_favorites
                    exp_image = icon_system_favorites ) TO lt_tree_nodes.

    "Construct Nodes Table with Scenario Nodes
    LOOP AT lt_mm_document_flow ASSIGNING FIELD-SYMBOL(<fs_mm_document_flow>) GROUP BY <fs_mm_document_flow>-document_category.

      APPEND VALUE #( hidden    = space
                      disabled  = space
                      isfolder  = abap_true
                      relatkey  = VALUE #( lt_tree_nodes[ 1 ]-node_key OPTIONAL )
                      relatship = cl_gui_simple_tree=>relat_last_child
                      node_key  = <fs_mm_document_flow>-document_category
                      text      = COND #( WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-qu  THEN 'Quotation'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-rfq THEN 'Request for Quotation'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-cn  THEN 'Contract'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-sa  THEN 'Scheduling Agreement'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-po  THEN 'Purchase Order'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-pr  THEN 'Purchase Requisition'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-md  THEN 'Material Document'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-inv THEN 'Invoice'
                                          ELSE <fs_mm_document_flow>-document_category )
                      expander  = abap_true
                      n_image   = icon_biw_formula
                      exp_image = icon_biw_formula ) TO lt_tree_nodes.

      LOOP AT GROUP <fs_mm_document_flow> ASSIGNING FIELD-SYMBOL(<fs_group_line>).

        APPEND VALUE #( hidden    = space
                        disabled  = space
                        isfolder  = space
                        relatkey  = <fs_group_line>-document_category
                        relatship = cl_gui_simple_tree=>relat_last_child
                        node_key  = | { <fs_group_line>-document_number ALPHA = OUT } | && <fs_group_line>-document_category
                        text      = CONV #( | { <fs_group_line>-document_number ALPHA = OUT } | )
                        expander  = space
                        n_image   = icon_patient_smartcard
                        exp_image = icon_patient_smartcard ) TO lt_tree_nodes.

      ENDLOOP.


    ENDLOOP.

  ENDMETHOD.

  METHOD create_tree.

    IF lo_tree IS NOT BOUND.

      DATA: lt_event_tab TYPE cntl_simple_events.

      "CREATE TREE OBJECTS
      CREATE OBJECT lo_tree
        EXPORTING
          parent              = NEW cl_gui_custom_container( container_name = im_container_name )
          node_selection_mode = cl_gui_simple_tree=>node_sel_mode_single.

      "EVENT HANGLING
      APPEND VALUE #( eventid = cl_gui_simple_tree=>eventid_node_double_click appl_event = space ) TO lt_event_tab.
      lo_tree->set_registered_events( EXPORTING events = lt_event_tab ).

      SET HANDLER me->handle_node_double_click FOR lo_tree.

      "ADD NODES TO TREE
      lo_tree->add_nodes(
        EXPORTING
          table_structure_name           = CONV #( CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( lt_tree_nodes[ 1 ] ) )->absolute_name+6 )
          node_table                     = lt_tree_nodes
        EXCEPTIONS
          error_in_node_table            = 1
          failed                         = 2
          dp_error                       = 3
          table_structure_name_not_found = 4
          OTHERS                         = 5 ).

      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Error Creating Tree'.
      ENDIF.

      "EXPAND NODES
      lo_tree->expand_root_nodes(
        EXPORTING
          level_count         = 3  " Number of Levels to be Expanded
          expand_subtree      = abap_true ": Expand all Subsequent Nodes
      EXCEPTIONS
        failed              = 1
        illegal_level_count = 2
        cntl_system_error   = 3
        OTHERS              = 4 ).

      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Error Creating Tree'.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD  handle_node_double_click.

    "RESET SELECTION STYLE
    LOOP AT lt_tree_nodes ASSIGNING FIELD-SYMBOL(<fs_node>).

      lo_tree->node_set_style(
        EXPORTING
          node_key          = <fs_node>-node_key
          style             = cl_gui_simple_tree=>style_default ).

    ENDLOOP.

    "RETRIEVE DATA FROM LINE SELECTED
    TRY.
        DATA(ls_selection) = lt_tree_nodes[ node_key = node_key ] .
      CATCH cx_sy_itab_line_not_found.
        RETURN.
    ENDTRY.

    "MARK LINE SELECTED
    lo_tree->node_set_style(
    EXPORTING
      node_key          = ls_selection-node_key
      style             = cl_gui_simple_tree=>style_emphasized_positive ).

    "CALL ALV HEADER-ITEM FOR PURCHASING DOCUMENT



    "REFRESH DATA
    cl_gui_cfw=>set_new_ok_code( EXPORTING new_code = 'FOO' ).

  ENDMETHOD.


ENDCLASS.

*&---------------------------------------------------------------------*
*& Class lcl_utilities
*&---------------------------------------------------------------------*
CLASS lcl_utilities IMPLEMENTATION.

  METHOD dynamic_where_clause.

    IF im_field IS NOT INITIAL AND im_comp IS NOT INITIAL AND im_val IS NOT INITIAL.

      "CHECK FIELD EXISTS IN CURRENT TABLE
      DATA(lv_field_exists) = lcl_utilities=>check_field_exists_in_table( EXPORTING im_field = im_field im_table = im_table_name ).
      CHECK lv_field_exists EQ abap_true.

      "Create Variable based on field Type
      DATA:dref TYPE REF TO data.

      DATA(type) = im_table_name && '-' && im_field.
      DATA(lv_data_type) =  cl_abap_typedescr=>describe_by_name( type )->type_kind.

      IF lv_data_type EQ 'D'."DATE
        DATA(lv_internal) = lcl_utilities=>date_external_to_internal( EXPORTING im_date = im_val ).
      ELSE."OTHER DATA TYPE

        CREATE DATA dref TYPE (type).
        ASSIGN dref->* TO FIELD-SYMBOL(<fs_val>).

        IF <fs_val> IS ASSIGNED.
          <fs_val> = im_val.
          lv_internal = lcl_utilities=>convert_to_internal_alpha( EXPORTING im_external = <fs_val> ).
        ELSE.
          lv_internal = im_val.
        ENDIF.

      ENDIF.

      DATA(lt_condtab) = VALUE hrtb_cond( ( field = im_field opera = im_comp low = lv_internal ) ).

      CALL FUNCTION 'RH_DYNAMIC_WHERE_BUILD'
        EXPORTING
          dbtable         = im_table_name
        TABLES
          condtab         = lt_condtab
          where_clause    = re_select_clause
        EXCEPTIONS
          empty_condtab   = 1
          no_db_field     = 2
          unknown_db      = 3
          wrong_condition = 4
          OTHERS          = 5.

    ENDIF.

  ENDMETHOD.

  METHOD check_field_exists_in_table.

    SELECT SINGLE @abap_true
      FROM dd03l
      INTO @re_exists
      WHERE tabname EQ   @im_table AND
            fieldname EQ @im_field.

  ENDMETHOD.

  METHOD convert_to_internal_alpha.

    DATA:wf_data      TYPE REF TO data.

*   Determine the mask(Conversion Exit) and Output Length of the Field
    DATA(lv_edit_mask) = CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_data( im_external ) )->edit_mask.
    DATA(lv_output_length) = CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_data( im_external ) )->output_length.

    IF lv_edit_mask IS INITIAL."ALPHA ROUTINE DOES NO EXISTS
      re_internal = |{ im_external ALPHA = IN }|.
      RETURN.
    ENDIF.

    REPLACE '==' IN lv_edit_mask WITH space.
    CONDENSE lv_edit_mask NO-GAPS.

    CREATE DATA wf_data TYPE c LENGTH lv_output_length.
    IF wf_data IS BOUND.
      ASSIGN wf_data->* TO FIELD-SYMBOL(<fs_t>).
      IF <fs_t> IS NOT ASSIGNED.
        IF re_internal IS INITIAL.
          re_internal = im_external.
        ENDIF.
        EXIT.
      ENDIF.
    ELSE.
      IF re_internal IS INITIAL.
        re_internal = im_external.
      ENDIF.
      EXIT.
    ENDIF.

    CONCATENATE 'CONVERSION_EXIT_' lv_edit_mask '_INPUT' INTO DATA(lv_convexit).

    CALL FUNCTION lv_convexit
      EXPORTING
        input  = im_external
      IMPORTING
        output = <fs_t>.

    IF sy-subrc NE 0.
      re_internal = im_external.
    ELSE.
      re_internal = <fs_t>.
    ENDIF.

  ENDMETHOD.

  METHOD date_external_to_internal.

    DATA: lv_convert_date TYPE c LENGTH 10.

    CLEAR:lv_convert_date.
    lv_convert_date = im_date.

    "date format YYYY/MM/DD
    FIND REGEX '^\d{4}[/|-|.|-]\d{1,2}[/|-|.|-]\d{1,2}$' IN lv_convert_date.
    IF sy-subrc = 0.
      CALL FUNCTION '/SAPDMC/LSM_DATE_CONVERT'
        EXPORTING
          date_in             = lv_convert_date
          date_format_in      = 'DYMD'
          to_output_format    = ' '
          to_internal_format  = 'X'
        IMPORTING
          date_out            = re_date_internal
        EXCEPTIONS
          illegal_date        = 1
          illegal_date_format = 2
          no_user_date_format = 3
          OTHERS              = 4.

    ELSE.

      " date format DD/MM/YYYY
      FIND REGEX '^\d{1,2}[/|-|.|-]\d{1,2}[/|-|.|-]\d{4}$' IN lv_convert_date.
      IF sy-subrc = 0.
        CALL FUNCTION '/SAPDMC/LSM_DATE_CONVERT'
          EXPORTING
            date_in             = lv_convert_date
            date_format_in      = 'DDMY'
            to_output_format    = ' '
            to_internal_format  = 'X'
          IMPORTING
            date_out            = re_date_internal
          EXCEPTIONS
            illegal_date        = 1
            illegal_date_format = 2
            no_user_date_format = 3
            OTHERS              = 4.
      ELSE.
        re_date_internal = lv_convert_date.
      ENDIF.

    ENDIF.

  ENDMETHOD.


ENDCLASS.

*&---------------------------------------------------------------------*
*& Class lcx_Exceptions
*&---------------------------------------------------------------------*
CLASS lcx_exceptions IMPLEMENTATION.

  METHOD constructor.

    super->constructor( textid = CONV #( text ) ).
    local_text = text.

  ENDMETHOD.

  METHOD get_text.

    result = me->local_text.

  ENDMETHOD.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Module PROCESS_BEFORE_OUTPUT OUTPUT
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  lo_mm_document_flow->process_before_output( ).

ENDMODULE.
*&---------------------------------------------------------------------*
*&      Module  PAI_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.

  DATA:ok_code_0100 TYPE sy-ucomm.

  lo_mm_document_flow->process_after_input( EXPORTING screen_okcode = ok_code_0100 ).

  CLEAR:ok_code_0100.

ENDMODULE.
