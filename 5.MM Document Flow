************************************************************************
*   Program name: MM Document Flow                                     *
*   Description :                                                      *
*                                                                      *
*   Created   by: GDRAKOS DVALOUXIS                                    *
*                                                                      *
************************************************************************
REPORT mm_document_flow NO STANDARD PAGE HEADING LINE-SIZE 255.

*&---------------------------------------------------------------------*
*& CONSTANTS
*&---------------------------------------------------------------------*
CONSTANTS: gc_tree_container TYPE char30     VALUE 'CC_0100_TREE',
           gc_screen_number  TYPE syst-dynnr VALUE '0100',
           gc_screen_status  TYPE gui_status VALUE 'SCREEN_STATUS',
           gc_screen_title   TYPE gui_title  VALUE 'SCREEN_TITLE'.

*&---------------------------------------------------------------------*
*& CLASS DEFINITIONS
*&---------------------------------------------------------------------*
CLASS: lcx_exceptions  DEFINITION DEFERRED,
       lcl_utilities   DEFINITION DEFERRED,
       lcl_mm_doc_flow DEFINITION DEFERRED.

*&---------------------------------------------------------------------*
*& Class LCX_TEXTS
*&---------------------------------------------------------------------*
CLASS lcx_exceptions DEFINITION INHERITING FROM cx_static_check.

  PUBLIC SECTION.

    METHODS:
      constructor IMPORTING text TYPE string,
      get_text REDEFINITION.

  PRIVATE SECTION.

    DATA:
          local_text TYPE string.

ENDCLASS.


*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.

    "PUBLIC METHODS
    METHODS:
      constructor IMPORTING im_document TYPE ekko-ebeln
                  RAISING   lcx_exceptions,

      process_before_output RAISING   lcx_exceptions,

      process_after_input   RAISING   lcx_exceptions.

  PRIVATE SECTION.

    "PRIVATE TYPES
    TYPES:
      BEGIN OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category BASE TYPE char03,
        purchase_requisition  VALUE 'PR',
        request_for_quotation VALUE 'RFQ',
        contract              VALUE 'CN',
        scheduling_agreement  VALUE 'SA',
        purchase_order        VALUE 'PO',
        material_document     VALUE 'MD',
        invoice               VALUE 'INV',
        undefined             VALUE IS INITIAL,
      END OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category ,

      BEGIN OF ty_mm_document_flow,
        document_number              TYPE ebeln,
        document_category            TYPE ty_enum_mm_document_category,
        movement_type                TYPE bwart,
        movement_type_description    TYPE btext,
        transaction_type             TYPE vgabe,
        transaction_type_description TYPE ddtext,
      END OF ty_mm_document_flow.

    "PRIVATE DATA
    DATA:
      lv_document          TYPE ekko-ebeln,
      lv_document_category TYPE ty_enum_mm_document_category,
      lt_mm_document_flow  TYPE TABLE OF ty_mm_document_flow WITH DEFAULT KEY INITIAL SIZE 0,
      lt_tree_nodes        TYPE TABLE OF mtreesnode WITH DEFAULT KEY INITIAL SIZE 0,
      lo_tree              TYPE REF TO cl_gui_simple_tree.

    "PRIVATE METHODS
    METHODS:

      create_tree IMPORTING im_container_name TYPE char30
                  RAISING   lcx_exceptions,

      determine_document_category IMPORTING im_document                 TYPE ekko-ebeln
                                  RETURNING VALUE(re_document_category) TYPE ty_enum_mm_document_category
                                  RAISING   lcx_exceptions,

      get_mm_document_flow,

      get_flow_from_po.

    "PRIVATE EVENT METHODS
    METHODS:
      handle_node_double_click  FOR EVENT node_double_click  OF cl_gui_simple_tree IMPORTING node_key,
      handle_expand_no_children FOR EVENT expand_no_children OF cl_gui_simple_tree IMPORTING node_key.


ENDCLASS.

*&---------------------------------------------------------------------*
*& Class lcl_utilities
*&---------------------------------------------------------------------*
CLASS lcl_utilities DEFINITION CREATE PUBLIC FINAL.

  PUBLIC SECTION.

    CLASS-METHODS:

      dynamic_where_clause IMPORTING im_field                TYPE char5
                                     im_comp                 TYPE ddoption DEFAULT if_fsbp_const_range=>option_equal
                                     im_val                  TYPE string
                                     im_table_name           TYPE tabname
                           RETURNING VALUE(re_select_clause) TYPE hrtb_cond,

      date_external_to_internal IMPORTING im_date                 TYPE string
                                RETURNING VALUE(re_date_internal) TYPE tumls_date,


      convert_to_internal_alpha IMPORTING im_external        TYPE any
                                RETURNING VALUE(re_internal) TYPE string.

  PRIVATE SECTION.

    CLASS-METHODS:

      check_field_exists_in_table IMPORTING im_field         TYPE char5
                                            im_table         TYPE tabname30
                                  RETURNING VALUE(re_exists) TYPE abap_bool.



ENDCLASS.
*&---------------------------------------------------------------------*
*& SELECTION SCREEN DESIGN
*&---------------------------------------------------------------------*

SELECTION-SCREEN: BEGIN OF BLOCK b00 WITH FRAME TITLE title1.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_doc FOR FIELD p_doc.
PARAMETERS : p_doc TYPE ekpo-ebeln OBLIGATORY.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: END OF BLOCK b00.

*&---------------------------------------------------------------------*
*& INITIALIZATION OF SELECTION SCREEN ELEMENTS
*&---------------------------------------------------------------------*
INITIALIZATION.
  PERFORM screen_initialization.

*&---------------------------------------------------------------------*
*& EXECUTABLE CODE
*&---------------------------------------------------------------------*
START-OF-SELECTION.

  TRY.
      DATA(lo_mm_document_flow) = NEW lcl_mm_doc_flow( im_document = p_doc ).
      CALL SCREEN gc_screen_number.
    CATCH lcx_exceptions.
  ENDTRY.

END-OF-SELECTION.

*&---------------------------------------------------------------------*
*& SUBROUTINE CREATION
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Form SCREEN INITIALIZATION
*&---------------------------------------------------------------------*
FORM screen_initialization.

  title1  = 'Purchasing Document Selection'.
  t_doc   = 'MM Document'.

ENDFORM.

*&---------------------------------------------------------------------*
*& CLASS IMPLEMENTATIONS
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Class lcx_Exceptions
*&---------------------------------------------------------------------*
CLASS lcx_exceptions IMPLEMENTATION.

  METHOD constructor.

    super->constructor( textid = CONV #( text ) ).
    local_text = text.

  ENDMETHOD.

  METHOD get_text.

    result = me->local_text.

  ENDMETHOD.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow IMPLEMENTATION.

  METHOD constructor.

    CLEAR:lv_document_category,lv_document.

    lv_document = im_document.
    lv_document_category = me->determine_document_category( EXPORTING im_document = lv_document ).

    me->get_mm_document_flow( ).


  ENDMETHOD.

  METHOD process_before_output.

    me->create_tree( im_container_name = gc_tree_container ).

  ENDMETHOD.


  METHOD process_after_input.



  ENDMETHOD.

  METHOD create_tree.

    IF lo_tree IS NOT BOUND.

      DATA: lt_event_tab TYPE cntl_simple_events.

      "CREATE TREE OBJECTS
      CREATE OBJECT lo_tree
        EXPORTING
          parent              = NEW cl_gui_custom_container( container_name = im_container_name )
          node_selection_mode = cl_gui_simple_tree=>node_sel_mode_single.

      "EVENT HANGLING
      APPEND VALUE #( eventid = cl_gui_simple_tree=>eventid_node_double_click appl_event = ' ' ) TO lt_event_tab.
      lo_tree->set_registered_events( EXPORTING events = lt_event_tab ).
      SET HANDLER me->handle_node_double_click FOR lo_tree.

*      "ADD NODES TO TREE
      lo_tree->add_nodes(
        EXPORTING
          table_structure_name           = 'MTREESNODE'
          node_table                     = lt_tree_nodes
        EXCEPTIONS
          error_in_node_table            = 1
          failed                         = 2
          dp_error                       = 3
          table_structure_name_not_found = 4
          OTHERS                         = 5 ).

      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Error Creating Tree'.
      ENDIF.

      "EXPAND NODES
      lo_tree->expand_root_nodes(
        EXPORTING
          level_count         =  3  " Number of Levels to be Expanded
          expand_subtree      = abap_true ": Expand all Subsequent Nodes
      EXCEPTIONS
        failed              = 1
        illegal_level_count = 2
        cntl_system_error   = 3
        OTHERS              = 4 ).

      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Error Creating Tree'.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD determine_document_category.

    "PURCHASE REQUISITION
    SELECT SINGLE @abap_true FROM eban WHERE banfn EQ @im_document AND bstyp EQ 'B' INTO @DATA(lv_exists).

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      re_document_category = me->mm_document_category-purchase_requisition.
      RETURN.
    ENDIF.

    "CONTRACT

    "RFQ

    "SCHEDULING AGREEMENT

    "PURCHASE ORDER
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @im_document AND bstyp EQ 'F' INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      re_document_category = me->mm_document_category-purchase_order.
      RETURN.
    ENDIF.

    "MATERIAL DOCUMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM mkpf WHERE mblnr EQ @im_document INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      re_document_category = me->mm_document_category-material_document.
      RETURN.
    ENDIF.

    "INVOICE
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM rbkp WHERE belnr EQ @im_document INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      re_document_category = me->mm_document_category-invoice.
      RETURN.
    ENDIF.

    "NOT FOUND
    RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Document Not Found'.

  ENDMETHOD.

  METHOD get_mm_document_flow.

    CASE me->lv_document_category.

      WHEN me->mm_document_category-purchase_requisition.

      WHEN me->mm_document_category-purchase_order.

        me->get_flow_from_po( ).

      WHEN me->mm_document_category-invoice.

      WHEN me->mm_document_category-material_document.

    ENDCASE.


  ENDMETHOD.

  METHOD get_flow_from_po.

    DATA(lt_vgabe_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'VGABE' ) )->get_ddic_fixed_values( sy-langu ).
    DATA(lt_bsart_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'BSART' ) )->get_ddic_fixed_values( sy-langu ).

*    "Purchase Requisition
*    SELECT DISTINCT ( eban~banfn ) AS document_number,
*      mm_document_category-purchase_requisition AS document_category,
*      ' ' AS movement_type,' ' AS movement_type_description,
*      ' ' AS transaction_type,
*      ' ' AS transaction_type_description
*
*      FROM ekpo
*      INNER JOIN eban ON eban~banfn EQ ekpo~banfn
*      WHERE ekpo~ebeln EQ @lv_document AND
*              eban~bstyp EQ 'B'
*
*    UNION DISTINCT
*
*    "Material Document and Invoice
*    SELECT DISTINCT ( ekbe~belnr ) AS document_number,
*
*     CASE WHEN  ekbe~bwart IS INITIAL THEN @lv_invoice
*          WHEN  ekbe~bwart IS NOT INITIAL THEN @lv_material_doc END AS document_category,
*     ekbe~bwart AS movement_type,t156ht~btext AS movement_type_description,ekbe~vgabe AS transaction_type, a~ddtext AS transaction_type_description
*
*    FROM ekbe
*    LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
*    LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
*    WHERE ebeln EQ @lv_document
*
*    INTO TABLE @lt_mm_document_flow .
*
*    BREAK-POINT.

  ENDMETHOD.

  METHOD  handle_node_double_click.

    cl_gui_cfw=>set_new_ok_code( EXPORTING new_code = 'FOO' ).

  ENDMETHOD.

  METHOD handle_expand_no_children.


  ENDMETHOD.


ENDCLASS.

*&---------------------------------------------------------------------*
*& Class lcl_utilities
*&---------------------------------------------------------------------*
CLASS lcl_utilities IMPLEMENTATION.

  METHOD dynamic_where_clause.

    IF im_field IS NOT INITIAL AND im_comp IS NOT INITIAL AND im_val IS NOT INITIAL.

      "CHECK FIELD EXISTS IN CURRENT TABLE
      DATA(lv_field_exists) = lcl_utilities=>check_field_exists_in_table( EXPORTING im_field = im_field im_table = im_table_name ).
      CHECK lv_field_exists EQ abap_true.

      "Create Variable based on field Type
      DATA:dref TYPE REF TO data.

      DATA(type) = im_table_name && '-' && im_field.
      DATA(lv_data_type) =  cl_abap_typedescr=>describe_by_name( type )->type_kind.

      IF lv_data_type EQ 'D'."DATE
        DATA(lv_internal) = lcl_utilities=>date_external_to_internal( EXPORTING im_date = im_val ).
      ELSE."OTHER DATA TYPE

        CREATE DATA dref TYPE (type).
        ASSIGN dref->* TO FIELD-SYMBOL(<fs_val>).

        IF <fs_val> IS ASSIGNED.
          <fs_val> = im_val.
          lv_internal = lcl_utilities=>convert_to_internal_alpha( EXPORTING im_external = <fs_val> ).
        ELSE.
          lv_internal = im_val.
        ENDIF.

      ENDIF.

      DATA(lt_condtab) = VALUE hrtb_cond( ( field = im_field opera = im_comp low = lv_internal ) ).

      CALL FUNCTION 'RH_DYNAMIC_WHERE_BUILD'
        EXPORTING
          dbtable         = im_table_name
        TABLES
          condtab         = lt_condtab
          where_clause    = re_select_clause
        EXCEPTIONS
          empty_condtab   = 1
          no_db_field     = 2
          unknown_db      = 3
          wrong_condition = 4
          OTHERS          = 5.

    ENDIF.

  ENDMETHOD.

  METHOD check_field_exists_in_table.

    SELECT SINGLE @abap_true
      FROM dd03l
      INTO @re_exists
      WHERE tabname EQ   @im_table AND
            fieldname EQ @im_field.

  ENDMETHOD.

  METHOD convert_to_internal_alpha.

    DATA:wf_data      TYPE REF TO data.

*   Determine the mask(Conversion Exit) and Output Length of the Field
    DATA(lv_edit_mask) = CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_data( im_external ) )->edit_mask.
    DATA(lv_output_length) = CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_data( im_external ) )->output_length.

    IF lv_edit_mask IS INITIAL."ALPHA ROUTINE DOES NO EXISTS
      re_internal = |{ im_external ALPHA = IN }|.
      RETURN.
    ENDIF.

    REPLACE '==' IN lv_edit_mask WITH space.
    CONDENSE lv_edit_mask NO-GAPS.

    CREATE DATA wf_data TYPE c LENGTH lv_output_length.
    IF wf_data IS BOUND.
      ASSIGN wf_data->* TO FIELD-SYMBOL(<fs_t>).
      IF <fs_t> IS NOT ASSIGNED.
        IF re_internal IS INITIAL.
          re_internal = im_external.
        ENDIF.
        EXIT.
      ENDIF.
    ELSE.
      IF re_internal IS INITIAL.
        re_internal = im_external.
      ENDIF.
      EXIT.
    ENDIF.

    CONCATENATE 'CONVERSION_EXIT_' lv_edit_mask '_INPUT' INTO DATA(lv_convexit).

    CALL FUNCTION lv_convexit
      EXPORTING
        input  = im_external
      IMPORTING
        output = <fs_t>.

    IF sy-subrc NE 0.
      re_internal = im_external.
    ELSE.
      re_internal = <fs_t>.
    ENDIF.

  ENDMETHOD.

  METHOD date_external_to_internal.

    DATA: lv_convert_date TYPE c LENGTH 10.

    CLEAR:lv_convert_date.
    lv_convert_date = im_date.

    "date format YYYY/MM/DD
    FIND REGEX '^\d{4}[/|-|.|-]\d{1,2}[/|-|.|-]\d{1,2}$' IN lv_convert_date.
    IF sy-subrc = 0.
      CALL FUNCTION '/SAPDMC/LSM_DATE_CONVERT'
        EXPORTING
          date_in             = lv_convert_date
          date_format_in      = 'DYMD'
          to_output_format    = ' '
          to_internal_format  = 'X'
        IMPORTING
          date_out            = re_date_internal
        EXCEPTIONS
          illegal_date        = 1
          illegal_date_format = 2
          no_user_date_format = 3
          OTHERS              = 4.

    ELSE.

      " date format DD/MM/YYYY
      FIND REGEX '^\d{1,2}[/|-|.|-]\d{1,2}[/|-|.|-]\d{4}$' IN lv_convert_date.
      IF sy-subrc = 0.
        CALL FUNCTION '/SAPDMC/LSM_DATE_CONVERT'
          EXPORTING
            date_in             = lv_convert_date
            date_format_in      = 'DDMY'
            to_output_format    = ' '
            to_internal_format  = 'X'
          IMPORTING
            date_out            = re_date_internal
          EXCEPTIONS
            illegal_date        = 1
            illegal_date_format = 2
            no_user_date_format = 3
            OTHERS              = 4.
      ELSE.
        re_date_internal = lv_convert_date.
      ENDIF.

    ENDIF.

  ENDMETHOD.


ENDCLASS.
*&---------------------------------------------------------------------*
*& Module PROCESS_BEFORE_OUTPUT OUTPUT
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
MODULE pbo_0100 OUTPUT.

* SET PF-STATUS gv_screen_status.
* SET TITLEBAR gv_screen_title.

  lo_mm_document_flow->process_before_output( ).

ENDMODULE.
*&---------------------------------------------------------------------*
*&      Module  PAI_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE pai_0100 INPUT.

  lo_mm_document_flow->process_after_input( ).

ENDMODULE.
