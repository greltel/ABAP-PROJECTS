************************************************************************
*   Program name: MM Document Flow                                     *
*   Description :                                                      *
*                                                                      *
*   Created   by: GDRAKOS                                              *
*                                                                      *
************************************************************************
REPORT mm_document_flow NO STANDARD PAGE HEADING LINE-SIZE 255.

*&---------------------------------------------------------------------*
*& CONSTANTS
*&---------------------------------------------------------------------*
CONSTANTS: gc_screen_container TYPE char30     VALUE 'CC_0100',
           gc_screen_number    TYPE syst-dynnr VALUE '0100',
           gc_screen_status    TYPE gui_status VALUE 'Z_SCREEN_STATUS_0100',
           gc_screen_title     TYPE gui_title  VALUE 'Z_SCREEN_TITLE_0100'.

*&---------------------------------------------------------------------*
*& CLASS DEFINITIONS
*&---------------------------------------------------------------------*
CLASS: lcl_mm_doc_flow DEFINITION DEFERRED,
       lcx_exceptions  DEFINITION DEFERRED.

*&---------------------------------------------------------------------*
*& Class LCX_TEXTS
*&---------------------------------------------------------------------*
CLASS lcx_exceptions DEFINITION INHERITING FROM cx_static_check.

  PUBLIC SECTION.

    METHODS:
      constructor IMPORTING text TYPE string,
      get_text REDEFINITION.

  PRIVATE SECTION.

    DATA:
          local_text TYPE string.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow DEFINITION CREATE PRIVATE FINAL.

  PUBLIC SECTION.

    "Signleton implementation to avoid global data
    CLASS-METHODS:
      get_instance RETURNING VALUE(ro_instance) TYPE REF TO lcl_mm_doc_flow.

    "PUBLIC METHODS
    METHODS:
      execute    IMPORTING im_document       TYPE ekko-ebeln
                           im_tree_container TYPE char30
                           im_screen_status  TYPE gui_status
                           im_screen_title   TYPE gui_title
                           im_screen_number  TYPE syst-dynnr
                 RAISING   lcx_exceptions,

      process_before_output RAISING lcx_exceptions,

      process_after_input IMPORTING screen_okcode TYPE syst-ucomm
                          RAISING   lcx_exceptions.

  PROTECTED SECTION.

  PRIVATE SECTION.

    "PRIVATE TYPES
    TYPES:

      BEGIN OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category BASE TYPE char03,
        pr        VALUE 'PR',
        rfq       VALUE 'RFQ',
        qu        VALUE 'QU',
        cn        VALUE 'CN',
        sa        VALUE 'SA',
        po        VALUE 'PO',
        md        VALUE 'MD',
        inv       VALUE 'INV',
        undefined VALUE IS INITIAL,
      END OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category,

      BEGIN OF ty_mm_document_flow,
        document_number              TYPE ebeln,
        document_category            TYPE ty_enum_mm_document_category,
        movement_type                TYPE bwart,
        movement_type_description    TYPE btext,
        transaction_type             TYPE vgabe,
        transaction_type_description TYPE ddtext,
        document_creation_date       TYPE datum,
        document_creation_time       TYPE tims,
      END OF ty_mm_document_flow,

      tt_mm_document_flow TYPE TABLE OF ty_mm_document_flow WITH DEFAULT KEY INITIAL SIZE 0,
      tt_trees_node       TYPE TABLE OF mtreesnode WITH DEFAULT KEY INITIAL SIZE 0.

    " Singleton implementation to avoid global data
    CLASS-DATA:
      mo_instance TYPE REF TO lcl_mm_doc_flow.

    "PRIVATE DATA
    DATA:
      lv_document          TYPE ekko-ebeln,
      lv_document_category TYPE ty_enum_mm_document_category,
      lv_screen_container  TYPE char30,
      lv_screen_status     TYPE gui_status,
      lv_screen_title      TYPE gui_title,
      lv_screen_number     TYPE syst-dynnr,
      lt_mm_document_flow  TYPE tt_mm_document_flow,
      lt_tree_nodes        TYPE tt_trees_node,
      lo_tree              TYPE REF TO cl_gui_simple_tree.

    "PRIVATE METHODS
    METHODS:

      create_containers RAISING lcx_exceptions,

      create_tree RAISING   lcx_exceptions,

      determine_document_category RAISING   lcx_exceptions,

      get_mm_document_flow RAISING   lcx_exceptions,

      get_flow_from_pr RAISING   lcx_exceptions,

      get_flow_from_po RAISING   lcx_exceptions,

      get_flow_from_md RAISING   lcx_exceptions,

      get_flow_from_inv RAISING   lcx_exceptions,

      build_node_table RAISING   lcx_exceptions.

    "PRIVATE EVENT METHODS
    METHODS:
      handle_node_double_click  FOR EVENT node_double_click  OF cl_gui_simple_tree IMPORTING node_key.

ENDCLASS.

*&---------------------------------------------------------------------*
*& SELECTION SCREEN DESIGN
*&---------------------------------------------------------------------*

SELECTION-SCREEN: BEGIN OF BLOCK b00 WITH FRAME TITLE title1.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_doc FOR FIELD p_doc.
PARAMETERS : p_doc TYPE ekpo-ebeln OBLIGATORY.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: END OF BLOCK b00.

*&---------------------------------------------------------------------*
*& INITIALIZATION OF SELECTION SCREEN ELEMENTS
*&---------------------------------------------------------------------*
INITIALIZATION.
  PERFORM screen_initialization.

*&---------------------------------------------------------------------*
*& EXECUTABLE CODE
*&---------------------------------------------------------------------*
START-OF-SELECTION.

  TRY.
      lcl_mm_doc_flow=>get_instance( )->execute( im_document = p_doc
                                                 im_tree_container = gc_screen_container
                                                 im_screen_status = gc_screen_status
                                                 im_screen_title = gc_screen_title
                                                 im_screen_number = gc_screen_number ).
    CATCH lcx_exceptions INTO DATA(lo_exception).
      MESSAGE lo_exception->get_text( ) TYPE 'I' DISPLAY LIKE 'E'.
  ENDTRY.

END-OF-SELECTION.

*&---------------------------------------------------------------------*
*& SUBROUTINE CREATION
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Form SCREEN INITIALIZATION
*&---------------------------------------------------------------------*
FORM screen_initialization.

  title1  = 'Purchasing Document Selection'.
  t_doc   = 'MM Document'.

ENDFORM.

*&---------------------------------------------------------------------*
*& CLASS IMPLEMENTATIONS
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow IMPLEMENTATION.

  METHOD get_instance.

    IF mo_instance IS INITIAL.
      CREATE OBJECT mo_instance.
    ENDIF.

    ro_instance = mo_instance.

  ENDMETHOD.

  METHOD execute.

    CLEAR:me->lv_document_category,me->lv_document.

    "ATTRIBUTES
    me->lv_document = im_document.
    me->lv_screen_container = im_tree_container.
    me->lv_screen_status = im_screen_status.
    me->lv_screen_title = im_screen_title.
    me->lv_screen_number = im_screen_number.

    "METHODS
    me->determine_document_category( ).
    me->get_mm_document_flow( ).
    me->build_node_table( ).

    CALL SCREEN me->lv_screen_number.

  ENDMETHOD.

  METHOD process_before_output.

    SET PF-STATUS me->lv_screen_status.
    SET TITLEBAR  me->lv_screen_title.

    me->create_containers( ).
    me->create_tree( ).

  ENDMETHOD.


  METHOD process_after_input.

    CASE screen_okcode.
      WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
        LEAVE TO SCREEN 0.
    ENDCASE.

  ENDMETHOD.

  METHOD determine_document_category.

    CLEAR:me->lv_document_category.

    "PURCHASE REQUISITION
    SELECT SINGLE @abap_true FROM eban WHERE banfn EQ @me->lv_document AND bstyp EQ 'B' INTO @DATA(lv_exists).

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-pr.
      RETURN.
    ENDIF.

    "REQUEST FOR QUOTATION
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'R' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-rfq.
      RETURN.
    ENDIF.

    "QUOTATION
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'O' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-qu.
      RETURN.
    ENDIF.

    "CONTRACT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'K' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-cn.
      RETURN.
    ENDIF.

    "SCHEDULING AGREEMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'L' INTO @lv_exists.
    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-sa.
      RETURN.
    ENDIF.

    "PURCHASE ORDER
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ 'F' INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-po.
      RETURN.
    ENDIF.

    "MATERIAL DOCUMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM mkpf WHERE mblnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-md.
      RETURN.
    ENDIF.

    "INVOICE
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM rbkp WHERE belnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc EQ 0 AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-inv.
      RETURN.
    ENDIF.

    "NOT FOUND
    RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Document Not Found'.

  ENDMETHOD.

  METHOD get_mm_document_flow.

    CASE me->lv_document_category.

      WHEN me->mm_document_category-pr.

        me->get_flow_from_pr( ).

      WHEN me->mm_document_category-po.

        me->get_flow_from_po( ).

      WHEN me->mm_document_category-md.

        me->get_flow_from_md( ).

      WHEN me->mm_document_category-inv.

        me->get_flow_from_inv( ).

    ENDCASE.

  ENDMETHOD.

  METHOD get_flow_from_pr.

    "Purchase Requisition
    SELECT SINGLE
      eban~banfn  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time

      FROM eban
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ 'I'
      WHERE eban~banfn EQ @lv_document AND
            eban~bstyp EQ 'B'
      INTO @DATA(ls_pr).

    IF sy-subrc EQ 0 AND ls_pr IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_pr-document_number
                      document_category      = mm_document_category-pr
                      document_creation_date = ls_pr-document_creation_date
                      document_creation_time = ls_pr-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Outline agreement( Contract and Scheduling Agreement )
    SELECT
      DISTINCT ( ekpo~konnr )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time
    FROM ekpo
    INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN eban ON ekpo~banfn EQ eban~banfn
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~banfn EQ @lv_document AND
          ekpo~konnr IS NOT INITIAL
    INTO TABLE @DATA(lt_oa).

    IF sy-subrc EQ 0 AND lt_oa IS NOT INITIAL.

      LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<fs_oa>).

        SELECT SINGLE bstyp FROM ekpo WHERE konnr EQ @<fs_oa>-document_number AND banfn EQ @lv_document INTO @DATA(lv_document_category).

        APPEND VALUE #( document_number      = <fs_oa>-document_number
                      document_category      = COND #( WHEN lv_document_category EQ 'K' THEN mm_document_category-cn
                                                       WHEN lv_document_category EQ 'L' THEN mm_document_category-sa
                                                       ELSE mm_document_category-cn )
                      document_creation_date = <fs_oa>-document_creation_date
                      document_creation_time = <fs_oa>-document_creation_time ) TO lt_mm_document_flow.

        CLEAR:lv_document_category.
      ENDLOOP.

    ENDIF.

    "Purchase Order
    SELECT
    DISTINCT ( ekko~ebeln )  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN eban ON ekpo~banfn EQ eban~banfn
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~banfn EQ @lv_document
    INTO TABLE @DATA(lt_po).

    IF sy-subrc EQ 0 AND lt_po IS NOT INITIAL.
      LOOP AT lt_po ASSIGNING FIELD-SYMBOL(<fs_po>).

        APPEND VALUE #( document_number        = <fs_po>-document_number
                        document_category      = mm_document_category-po
                        document_creation_date = <fs_po>-document_creation_date
                        document_creation_time = <fs_po>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.
    ENDIF.

    "Material Document
    SELECT
     DISTINCT ( ekbe~belnr ) AS document_number,
     ekbe~bwart AS movement_type,
     t156ht~btext AS movement_type_description,
     ekbe~vgabe AS transaction_type,
     ekbe~cpudt AS document_creation_date,
     ekbe~cputm AS document_creation_time

      FROM ekbe
      INNER JOIN @lt_po AS a ON a~document_number EQ ekbe~ebeln
      LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
      WHERE  ekbe~bwart IS NOT INITIAL
      INTO TABLE @DATA(lt_md).

    IF sy-subrc EQ 0 AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "INVOICE
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

   FROM ekbe
   INNER JOIN @lt_po AS a ON a~document_number EQ ekbe~ebeln
   LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
   WHERE ekbe~bwart IS INITIAL
   INTO TABLE @DATA(lt_inv).

    IF sy-subrc EQ 0 AND lt_inv IS NOT INITIAL.

      LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

        APPEND VALUE #( document_number              = <fs_inv>-document_number
                        document_category            = mm_document_category-inv
                        movement_type                = <fs_inv>-movement_type
                        movement_type_description    = <fs_inv>-movement_type_description
                        transaction_type             = <fs_inv>-transaction_type
                        document_creation_date       = <fs_inv>-document_creation_date
                        document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_po.

    DATA(lt_vgabe_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'VGABE' ) )->get_ddic_fixed_values( sy-langu ).
    DATA(lt_bsart_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'BSART' ) )->get_ddic_fixed_values( sy-langu ).

    "Purchase Requisition
    SELECT
      DISTINCT ( eban~banfn )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time

      FROM ekpo
      INNER JOIN eban ON eban~banfn EQ ekpo~banfn
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ 'I'
      WHERE ekpo~ebeln EQ @lv_document AND
            eban~bstyp EQ 'B'
      INTO TABLE @DATA(lt_pr).

    IF sy-subrc EQ 0 AND lt_pr IS NOT INITIAL.

      LOOP AT lt_pr ASSIGNING FIELD-SYMBOL(<fs_pr>).
        APPEND VALUE #( document_number        = <fs_pr>-document_number
                        document_category      = mm_document_category-pr
                        document_creation_date = <fs_pr>-document_creation_date
                        document_creation_time = <fs_pr>-document_creation_time ) TO lt_mm_document_flow.
      ENDLOOP.

    ENDIF.


    "Outline agreement( Contract and Scheduling Agreement )
    SELECT
      DISTINCT ( ekpo~konnr )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time
    FROM ekpo
    INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~ebeln EQ @lv_document AND
          ekpo~konnr IS NOT INITIAL
    INTO TABLE @DATA(lt_oa).

    IF sy-subrc EQ 0 AND lt_oa IS NOT INITIAL.

      LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<ls_oa>).

        SELECT SINGLE bstyp FROM ekko WHERE ebeln EQ @<ls_oa>-document_number INTO @DATA(lv_document_category).

        APPEND VALUE #( document_number      = <ls_oa>-document_number
                      document_category      = COND #( WHEN lv_document_category EQ 'K' THEN mm_document_category-cn
                                                       WHEN lv_document_category EQ 'L' THEN mm_document_category-sa
                                                       ELSE mm_document_category-cn )
                      document_creation_date = <ls_oa>-document_creation_date
                      document_creation_time = <ls_oa>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.



    ENDIF.

    "Purchase Order
    SELECT SINGLE
    ekko~ebeln  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ 'I'
    WHERE ekpo~ebeln EQ @lv_document
    INTO @DATA(ls_po).

    IF sy-subrc EQ 0 AND ls_po IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_po-document_number
                      document_category      = mm_document_category-po
                      document_creation_date = ls_po-document_creation_date
                      document_creation_time = ls_po-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Material Document
    SELECT
     DISTINCT ( ekbe~belnr ) AS document_number,
     ekbe~bwart AS movement_type,
     t156ht~btext AS movement_type_description,
     ekbe~vgabe AS transaction_type,
     a~ddtext AS transaction_type_description,
     ekbe~cpudt AS document_creation_date,
     ekbe~cputm AS document_creation_time

      FROM ekbe
      LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
      LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
      WHERE ebeln EQ @lv_document AND
            ekbe~bwart IS NOT INITIAL
      INTO TABLE @DATA(lt_md).

    IF sy-subrc EQ 0 AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        transaction_type_description = <fs_md>-transaction_type_description
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "INVOICE
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    a~ddtext AS transaction_type_description,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

   FROM ekbe
   LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
   LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
   WHERE ebeln EQ @lv_document AND
         ekbe~bwart IS INITIAL
   INTO TABLE @DATA(lt_inv).

    IF sy-subrc EQ 0 AND lt_inv IS NOT INITIAL.

      LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

        APPEND VALUE #( document_number              = <fs_inv>-document_number
                        document_category            = mm_document_category-inv
                        movement_type                = <fs_inv>-movement_type
                        movement_type_description    = <fs_inv>-movement_type_description
                        transaction_type             = <fs_inv>-transaction_type
                        transaction_type_description = <fs_inv>-transaction_type_description
                        document_creation_date       = <fs_inv>-document_creation_date
                        document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_md.



  ENDMETHOD.


  METHOD get_flow_from_inv.



  ENDMETHOD.

  METHOD build_node_table.

    "ROOT NODE
    APPEND VALUE #( hidden    = space
                    disabled  = space
                    isfolder  = abap_true
                    node_key  = syst-repid
                    text      = |MM Document Flow Of { lv_document ALPHA = OUT } |
                    n_image   =  icon_system_favorites
                    exp_image = icon_system_favorites ) TO lt_tree_nodes.

    "Construct Nodes Table with Scenario Nodes
    LOOP AT lt_mm_document_flow ASSIGNING FIELD-SYMBOL(<fs_mm_document_flow>) GROUP BY <fs_mm_document_flow>-document_category.

      APPEND VALUE #( hidden    = space
                      disabled  = space
                      isfolder  = abap_true
                      relatkey  = VALUE #( lt_tree_nodes[ 1 ]-node_key OPTIONAL )
                      relatship = cl_gui_simple_tree=>relat_last_child
                      node_key  = <fs_mm_document_flow>-document_category
                      text      = COND #( WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-qu  THEN 'Quotation'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-rfq THEN 'Request for Quotation'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-cn  THEN 'Contract'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-sa  THEN 'Scheduling Agreement'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-po  THEN 'Purchase Order'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-pr  THEN 'Purchase Requisition'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-md  THEN 'Material Document'
                                          WHEN <fs_mm_document_flow>-document_category EQ mm_document_category-inv THEN 'Invoice'
                                          ELSE <fs_mm_document_flow>-document_category )
                      expander  = abap_true
                      n_image   = icon_biw_formula
                      exp_image = icon_biw_formula ) TO lt_tree_nodes.

      LOOP AT GROUP <fs_mm_document_flow> ASSIGNING FIELD-SYMBOL(<fs_group_line>).

        APPEND VALUE #( hidden    = space
                        disabled  = space
                        isfolder  = space
                        relatkey  = <fs_group_line>-document_category
                        relatship = cl_gui_simple_tree=>relat_last_child
                        node_key  = | { <fs_group_line>-document_number ALPHA = OUT } | && <fs_group_line>-document_category
                        text      = CONV #( | { <fs_group_line>-document_number ALPHA = OUT } | )
                        expander  = space
                        n_image   = icon_patient_smartcard
                        exp_image = icon_patient_smartcard ) TO lt_tree_nodes.

      ENDLOOP.


    ENDLOOP.

  ENDMETHOD.

  METHOD create_containers.


  ENDMETHOD.

  METHOD create_tree.

    IF lo_tree IS NOT BOUND.

      "CREATE TREE OBJECTS
      CREATE OBJECT lo_tree
        EXPORTING
          parent              = NEW cl_gui_custom_container( container_name = me->lv_screen_container )
          node_selection_mode = cl_gui_simple_tree=>node_sel_mode_single.

      "EVENT HANGLING
      DATA: lt_event_tab TYPE cntl_simple_events.

      APPEND VALUE #( eventid = cl_gui_simple_tree=>eventid_node_double_click appl_event = space ) TO lt_event_tab.
      lo_tree->set_registered_events( EXPORTING events = lt_event_tab ).

      SET HANDLER me->handle_node_double_click FOR lo_tree.

      "ADD NODES TO TREE
      lo_tree->add_nodes(
        EXPORTING
          table_structure_name           = CONV #( CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( lt_tree_nodes[ 1 ] ) )->absolute_name+6 )
          node_table                     = lt_tree_nodes
        EXCEPTIONS
          error_in_node_table            = 1
          failed                         = 2
          dp_error                       = 3
          table_structure_name_not_found = 4
          OTHERS                         = 5 ).

      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Error Creating Tree'.
      ENDIF.

      "EXPAND NODES
      lo_tree->expand_root_nodes(
        EXPORTING
          level_count         = 3  " Number of Levels to be Expanded
          expand_subtree      = abap_true ": Expand all Subsequent Nodes
      EXCEPTIONS
        failed              = 1
        illegal_level_count = 2
        cntl_system_error   = 3
        OTHERS              = 4 ).

      IF sy-subrc NE 0.
        RAISE EXCEPTION TYPE lcx_exceptions EXPORTING text = 'Error Creating Tree'.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD  handle_node_double_click.

    "RESET SELECTION STYLE
    LOOP AT lt_tree_nodes ASSIGNING FIELD-SYMBOL(<fs_node>).

      lo_tree->node_set_style(
        EXPORTING
          node_key          = <fs_node>-node_key
          style             = cl_gui_simple_tree=>style_default ).

    ENDLOOP.

    "RETRIEVE DATA FROM LINE SELECTED
    TRY.
        DATA(ls_selection) = lt_tree_nodes[ node_key = node_key ] .
      CATCH cx_sy_itab_line_not_found.
        RETURN.
    ENDTRY.

    "MARK LINE SELECTED
    lo_tree->node_set_style(
    EXPORTING
      node_key          = ls_selection-node_key
      style             = cl_gui_simple_tree=>style_emphasized_positive ).

    "CALL ALV HEADER-ITEM FOR PURCHASING DOCUMENT



    "REFRESH DATA
    cl_gui_cfw=>set_new_ok_code( EXPORTING new_code = 'FOO' ).

  ENDMETHOD.


ENDCLASS.

*&---------------------------------------------------------------------*
*& Class lcx_Exceptions
*&---------------------------------------------------------------------*
CLASS lcx_exceptions IMPLEMENTATION.

  METHOD constructor.

    super->constructor( textid = CONV #( text ) ).
    local_text = text.

  ENDMETHOD.

  METHOD get_text.

    result = me->local_text.

  ENDMETHOD.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Module PROCESS_BEFORE_OUTPUT OUTPUT
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  lcl_mm_doc_flow=>get_instance( )->process_before_output( ).

ENDMODULE.
*&---------------------------------------------------------------------*
*&      Module  PAI_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.

  DATA:ok_code_0100 TYPE sy-ucomm.

  lcl_mm_doc_flow=>get_instance( )->process_after_input( EXPORTING screen_okcode = ok_code_0100 ).

  CLEAR:ok_code_0100.

ENDMODULE.
