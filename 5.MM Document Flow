*&---------------------------------------------------------------------*
*& Program name: MM Document Flow
*& Description :
*&---------------------------------------------------------------------*
*& Created   By: GDRAKOS
*& Created   On:
*&---------------------------------------------------------------------*
REPORT z_mm_document_flow NO STANDARD PAGE HEADING LINE-SIZE 255.

*&--------------------------------------------------------------------&*
*&              M O D I F I C A T I O N    L O G                      &*
*&--------------------------------------------------------------------&*
*& Description    :                                                    *
*& Author         :                                                    *
*& Date           :                                                    *
*& Change Request :                                                    *
*&--------------------------------------------------------------------&*

*&---------------------------------------------------------------------*
*& GLOBAL CONSTANTS
*&---------------------------------------------------------------------*
CONSTANTS: gc_screen_container TYPE char30     VALUE 'CC_0100',
           gc_screen_number    TYPE syst-dynnr VALUE '0100',
           gc_screen_status    TYPE gui_status VALUE 'Z_SCREEN_STATUS_0100',
           gc_screen_title     TYPE gui_title  VALUE 'Z_SCREEN_TITLE_0100'.

*&---------------------------------------------------------------------*
*& CLASS DEFINITIONS
*&---------------------------------------------------------------------*
CLASS: lcl_mm_doc_flow DEFINITION DEFERRED,
       lcx_exception   DEFINITION DEFERRED.

*&----------------------------------------------------------------------*
*&CLASS LCX_EXCEPTION DEFINITION
*&----------------------------------------------------------------------*
CLASS lcx_exception DEFINITION INHERITING FROM cx_static_check FINAL CREATE PUBLIC.

  PUBLIC SECTION.

    METHODS:
      constructor IMPORTING im_text     TYPE bapiret2-message OPTIONAL
                            im_textid   TYPE texid OPTIONAL
                            im_previous TYPE REF TO  cx_root OPTIONAL,
      get_text              REDEFINITION,
      get_longtext          REDEFINITION.

  PRIVATE SECTION.

    DATA:
         mv_message TYPE bapiret2-message.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow DEFINITION CREATE PRIVATE FINAL.

  PUBLIC SECTION.

    "SINGLETON DESIGN PATTERN
    CLASS-METHODS:
      get_instance RETURNING VALUE(ro_instance) TYPE REF TO lcl_mm_doc_flow.

    "PUBLIC METHODS
    METHODS:
      execute    IMPORTING im_document       TYPE ekko-ebeln
                           im_document_year  TYPE rbkp-gjahr OPTIONAL
                           im_tree_container TYPE char30
                           im_screen_status  TYPE gui_status
                           im_screen_title   TYPE gui_title
                           im_screen_number  TYPE syst-dynnr
                 RAISING   lcx_exception,

      process_before_output RAISING lcx_exception,

      process_after_input IMPORTING screen_okcode TYPE syst-ucomm
                          RAISING   lcx_exception.

  PROTECTED SECTION.

  PRIVATE SECTION.

    "PRIVATE TYPES
    TYPES:

      BEGIN OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category BASE TYPE char03,
        pr        VALUE 'PR',
        rfq       VALUE 'RFQ',
        qu        VALUE 'QU',
        cn        VALUE 'CN',
        sa        VALUE 'SA',
        po        VALUE 'PO',
        md        VALUE 'MD',
        inv       VALUE 'INV',
        ac        VALUE 'AC',
        undefined VALUE IS INITIAL,
      END OF ENUM ty_enum_mm_document_category STRUCTURE mm_document_category,

      BEGIN OF ty_mm_document_flow,
        document_number              TYPE ebeln,
        document_category            TYPE ty_enum_mm_document_category,
        movement_type                TYPE bwart,
        movement_type_description    TYPE btext,
        transaction_type             TYPE vgabe,
        transaction_type_description TYPE ddtext,
        document_creation_date       TYPE datum,
        document_creation_time       TYPE tims,
      END OF ty_mm_document_flow,

      BEGIN OF ty_document_category_descr,
        document_bstyp          TYPE bstyp,
        document_category       TYPE ty_enum_mm_document_category,
        document_category_descr TYPE string,

      END OF ty_document_category_descr,

      tt_document_category_descr TYPE TABLE OF ty_document_category_descr WITH KEY primary_key COMPONENTS document_bstyp document_category INITIAL SIZE 0,
      tt_mm_document_flow        TYPE TABLE OF ty_mm_document_flow        WITH EMPTY KEY INITIAL SIZE 0,
      tt_trees_node              TYPE TABLE OF mtreesnode                 WITH EMPTY KEY INITIAL SIZE 0.

    CONSTANTS:

      BEGIN OF purchasing_document_category,
        info_record                VALUE 'I',
        service_entry_sheet        VALUE 'Q',
        simple_service_entry_sheet VALUE 'S',
        source_list                VALUE 'W',
        pr                         VALUE 'B',
        rfq                        VALUE 'R',
        rfq_2                      VALUE 'A',
        qu                         VALUE 'O',
        cn                         VALUE 'K',
        sa                         VALUE 'L',
        po                         VALUE 'F',
        cen_cn                     VALUE 'C',
        cen_po                     VALUE 'P',
      END OF purchasing_document_category,

      BEGIN OF type_of_document_change,
        change VALUE 'U',
        insert VALUE 'I',
        delete VALUE 'D',
      END OF type_of_document_change.

    "SINGLETON DESIGN PATTERN
    CLASS-DATA:
    mo_instance TYPE REF TO lcl_mm_doc_flow.

    "PRIVATE DATA
    DATA:
      lv_document                TYPE ekko-ebeln,
      lv_document_year           TYPE rbkp-gjahr,
      lv_document_category       TYPE ty_enum_mm_document_category,
      lv_screen_container        TYPE char30,
      lv_screen_status           TYPE gui_status,
      lv_screen_title            TYPE gui_title,
      lv_screen_number           TYPE syst-dynnr,
      lt_document_category_descr TYPE tt_document_category_descr,
      lt_mm_document_flow        TYPE tt_mm_document_flow,
      lt_tree_nodes              TYPE tt_trees_node,
      lo_tree                    TYPE REF TO cl_gui_simple_tree,
      "CONTAINERS
      lr_splitter_container      TYPE REF TO cl_gui_splitter_container,
      lr_left_container          TYPE REF TO cl_gui_container,
      lr_right_container         TYPE REF TO cl_gui_container,
      "ALV
      lo_alv_details             TYPE REF TO  cl_gui_alv_grid,
      lr_details_table           TYPE REF TO data.

    "PRIVATE METHODS
    METHODS:
      create_containers           RAISING lcx_exception,
      create_tree                 RAISING lcx_exception,
      populate_category_descr RAISING lcx_exception,
      determine_document_category RAISING lcx_exception,
      get_mm_document_flow        RAISING lcx_exception,
      get_flow_from_pr            RAISING lcx_exception,
      get_flow_from_qu            RAISING lcx_exception,
      get_flow_from_rfq           RAISING lcx_exception,
      get_flow_from_cn            RAISING lcx_exception,
      get_flow_from_sa            RAISING lcx_exception,
      get_flow_from_po            RAISING lcx_exception,
      get_flow_from_md            RAISING lcx_exception,
      get_flow_from_inv           RAISING lcx_exception,
      get_flow_from_ac            RAISING lcx_exception,
      display_document_details    IMPORTING im_document      TYPE ebeln
                                            im_document_cat  TYPE ty_enum_mm_document_category
                                            im_document_year TYPE gjahr OPTIONAL
                                  RAISING   lcx_exception,
      get_details_table           IMPORTING im_document      TYPE ebeln
                                            im_document_cat  TYPE ty_enum_mm_document_category
                                            im_document_year TYPE gjahr OPTIONAL
                                  RETURNING VALUE(re_table)  TYPE REF TO data
                                  RAISING   lcx_exception,
      build_node_table            RAISING lcx_exception,
      reset_tree_selection        RAISING lcx_exception.

    "TREE EVENT METHODS
    METHODS:
      handle_node_double_click FOR EVENT node_double_click OF cl_gui_simple_tree IMPORTING node_key.

    "ALV EVENT METHODS
    METHODS:
      handle_hotspot_click FOR EVENT hotspot_click OF cl_gui_alv_grid  IMPORTING e_row_id e_column_id es_row_no,
      toolbar              FOR EVENT toolbar       OF cl_gui_alv_grid  IMPORTING e_object,
      user_command         FOR EVENT user_command  OF cl_gui_alv_grid  IMPORTING e_ucomm.

ENDCLASS.

*&---------------------------------------------------------------------*
*& SELECTION SCREEN DESIGN
*&---------------------------------------------------------------------*

SELECTION-SCREEN: BEGIN OF BLOCK b00 WITH FRAME TITLE title0.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_doc FOR FIELD p_doc.
PARAMETERS : p_doc TYPE ekpo-ebeln OBLIGATORY.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_gjahr FOR FIELD p_gjahr.
PARAMETERS : p_gjahr TYPE rbkp-gjahr.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN: END OF BLOCK b00.

*&---------------------------------------------------------------------*
*& INITIALIZATION OF SELECTION SCREEN ELEMENTS
*&---------------------------------------------------------------------*
INITIALIZATION.
  PERFORM screen_initialization.

*&---------------------------------------------------------------------*
*& EXECUTABLE CODE
*&---------------------------------------------------------------------*
START-OF-SELECTION.

  TRY.
      lcl_mm_doc_flow=>get_instance( )->execute( im_document       = CONV #( p_doc )               ##OPERATOR[EBELN]
                                                 im_document_year  = CONV #( p_gjahr )             ##OPERATOR[GJAHR]
                                                 im_tree_container = CONV #( gc_screen_container ) ##OPERATOR[CHAR30]
                                                 im_screen_status  = CONV #( gc_screen_status )    ##OPERATOR[GUI_STATUS]
                                                 im_screen_title   = CONV #( gc_screen_title )     ##OPERATOR[GUI_TITLE]
                                                 im_screen_number  = CONV #( gc_screen_number )    ##OPERATOR[DYNNR]
                                                 ).
    CATCH lcx_exception INTO DATA(lo_exception).
      MESSAGE lo_exception->get_text( ) TYPE cl_cms_common=>con_msg_typ_i DISPLAY LIKE cl_cms_common=>con_msg_typ_e.
  ENDTRY.

END-OF-SELECTION.

*&---------------------------------------------------------------------*
*& SUBROUTINE CREATION
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Form SCREEN INITIALIZATION
*&---------------------------------------------------------------------*
FORM screen_initialization.

  title0  = 'Purchasing Document Selection'.
  t_doc   = 'Purchasing Document'.
  t_gjahr = 'Purchasing Document Year'.

ENDFORM.

*&---------------------------------------------------------------------*
*& CLASS IMPLEMENTATIONS
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Class LCL_MM_DOC_FLOW
*&---------------------------------------------------------------------*
CLASS lcl_mm_doc_flow IMPLEMENTATION.

  METHOD get_instance.

    IF mo_instance IS INITIAL.
      mo_instance = NEW #( ).
    ENDIF.

    ro_instance = mo_instance.

  ENDMETHOD.

  METHOD execute.

    CLEAR:me->lv_document_category,me->lv_document_year,me->lv_document.

    "ATTRIBUTES
    me->lv_document         = im_document.
    me->lv_document_year    = im_document_year.
    me->lv_screen_container = im_tree_container.
    me->lv_screen_status    = im_screen_status.
    me->lv_screen_title     = im_screen_title.
    me->lv_screen_number    = im_screen_number.

    "METHODS
    me->populate_category_descr( ).
    me->determine_document_category( ).
    me->get_mm_document_flow( ).
    me->build_node_table( ).

    CALL SCREEN me->lv_screen_number.

  ENDMETHOD.

  METHOD process_before_output.

    SET PF-STATUS me->lv_screen_status.
    SET TITLEBAR  me->lv_screen_title.

    me->create_containers( ).
    me->create_tree( ).

  ENDMETHOD.

  METHOD process_after_input.

    CALL METHOD cl_gui_cfw=>dispatch.

    CASE screen_okcode.
      WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
        LEAVE TO SCREEN 0.
      WHEN OTHERS.

    ENDCASE.

  ENDMETHOD.

  METHOD populate_category_descr.


    lt_document_category_descr = VALUE #( ( document_bstyp = 'B' document_category = mm_document_category-pr  document_category_descr = 'Purchase Requisition' )
                                          ( document_bstyp = 'R' document_category = mm_document_category-rfq document_category_descr = 'Request for Quotation' )
                                          ( document_bstyp = 'A' document_category = mm_document_category-rfq document_category_descr = 'Request for Quotation' )
                                          ( document_bstyp = 'O' document_category = mm_document_category-qu  document_category_descr = 'Quotation' )
                                          ( document_bstyp = 'K' document_category = mm_document_category-cn  document_category_descr = 'Contract' )
                                          ( document_bstyp = 'C' document_category = mm_document_category-cn  document_category_descr = 'Central Contract' )
                                          ( document_bstyp = 'L' document_category = mm_document_category-sa  document_category_descr = 'Scheduling Agreement' )
                                          ( document_bstyp = 'F' document_category = mm_document_category-po  document_category_descr = 'Purchase Order' )
                                          ( document_bstyp = 'P' document_category = mm_document_category-po  document_category_descr = 'Central Purchase Order' )
                                          ( document_bstyp = ''  document_category = mm_document_category-md  document_category_descr = 'Material Document' )
                                          ( document_bstyp = ''  document_category = mm_document_category-inv document_category_descr = 'Invoice' )
                                          ( document_bstyp = ''  document_category = mm_document_category-ac  document_category_descr = 'Accounting Document' ) ).


  ENDMETHOD.

  METHOD determine_document_category.

    CLEAR:me->lv_document_category.

    "PURCHASE REQUISITION
    SELECT SINGLE @abap_true FROM eban WHERE banfn EQ @me->lv_document AND bstyp EQ @me->purchasing_document_category-pr INTO @DATA(lv_exists).

    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-pr.
      RETURN.
    ENDIF.

    "REQUEST FOR QUOTATION
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ @me->purchasing_document_category-rfq INTO @lv_exists.
    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-rfq.
      RETURN.
    ENDIF.

    "QUOTATION
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ @me->purchasing_document_category-qu INTO @lv_exists.
    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-qu.
      RETURN.
    ENDIF.

    "CONTRACT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ @me->purchasing_document_category-cn INTO @lv_exists.
    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-cn.
      RETURN.
    ENDIF.

    "SCHEDULING AGREEMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ @me->purchasing_document_category-sa INTO @lv_exists.
    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-sa.
      RETURN.
    ENDIF.

    "PURCHASE ORDER
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM ekko WHERE ebeln EQ @me->lv_document AND bstyp EQ @me->purchasing_document_category-po INTO @lv_exists.

    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-po.
      RETURN.
    ENDIF.

    "MATERIAL DOCUMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM mkpf WHERE mblnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-md.
      RETURN.
    ENDIF.

    "INVOICE
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM rbkp WHERE belnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-inv.
      RETURN.
    ENDIF.

    "ACCOUNTING DOCUMENT
    CLEAR:lv_exists.
    SELECT SINGLE @abap_true FROM bkpf WHERE belnr EQ @me->lv_document INTO @lv_exists.

    IF sy-subrc IS INITIAL AND lv_exists EQ abap_true.
      me->lv_document_category = me->mm_document_category-ac.
      RETURN.
    ENDIF.

    "NOT FOUND
    RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Document Not Found'.

  ENDMETHOD.

  METHOD get_mm_document_flow.

    CASE me->lv_document_category.

      WHEN me->mm_document_category-pr.

        me->get_flow_from_pr( ).

      WHEN me->mm_document_category-rfq.

        me->get_flow_from_rfq( ).

      WHEN me->mm_document_category-qu.

        me->get_flow_from_qu( ).

      WHEN me->mm_document_category-sa.

        me->get_flow_from_sa( ).

      WHEN me->mm_document_category-cn.

        me->get_flow_from_cn( ).

      WHEN me->mm_document_category-po.

        me->get_flow_from_po( ).

      WHEN me->mm_document_category-md.

        me->get_flow_from_md( ).

      WHEN me->mm_document_category-inv.

        me->get_flow_from_inv( ).

      WHEN me->mm_document_category-ac.

        me->get_flow_from_ac( ).

      WHEN OTHERS.

        RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Document Flow Not Retrieved'.

    ENDCASE.

  ENDMETHOD.

  METHOD get_flow_from_pr.

    "Purchase Requisition
    SELECT SINGLE
      eban~banfn  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time

      FROM eban
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ @me->type_of_document_change-insert
      WHERE eban~banfn EQ @lv_document AND
            eban~bstyp EQ @me->purchasing_document_category-pr
      INTO @DATA(ls_pr).

    IF sy-subrc IS INITIAL AND ls_pr IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_pr-document_number
                      document_category      = mm_document_category-pr
                      document_creation_date = ls_pr-document_creation_date
                      document_creation_time = ls_pr-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Outline agreement( Contract and Scheduling Agreement )
    SELECT
      DISTINCT ( ekpo~konnr )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time
    FROM ekpo
    INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN eban ON ekpo~banfn EQ eban~banfn
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
    WHERE ekpo~banfn EQ @lv_document AND
          ekpo~konnr IS NOT INITIAL
    INTO TABLE @DATA(lt_oa).

    IF sy-subrc IS INITIAL AND lt_oa IS NOT INITIAL.

      LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<fs_oa>).

        SELECT SINGLE bstyp FROM ekpo WHERE konnr EQ @<fs_oa>-document_number AND banfn EQ @lv_document INTO @DATA(lv_document_category).

        APPEND VALUE #( document_number      = <fs_oa>-document_number
                      document_category      = COND #( WHEN lv_document_category EQ me->purchasing_document_category-cn THEN mm_document_category-cn
                                                       WHEN lv_document_category EQ me->purchasing_document_category-sa THEN mm_document_category-sa
                                                       ELSE mm_document_category-cn )
                      document_creation_date = <fs_oa>-document_creation_date
                      document_creation_time = <fs_oa>-document_creation_time ) TO lt_mm_document_flow.

        CLEAR:lv_document_category.
      ENDLOOP.

    ENDIF.

    "Purchase Order
    SELECT
    DISTINCT ( ekko~ebeln )  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN eban ON ekpo~banfn EQ eban~banfn
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
    WHERE ekpo~banfn EQ @lv_document
    INTO TABLE @DATA(lt_po).

    IF sy-subrc IS INITIAL AND lt_po IS NOT INITIAL.
      LOOP AT lt_po ASSIGNING FIELD-SYMBOL(<fs_po>).

        APPEND VALUE #( document_number        = <fs_po>-document_number
                        document_category      = mm_document_category-po
                        document_creation_date = <fs_po>-document_creation_date
                        document_creation_time = <fs_po>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.
    ENDIF.

    "Material Document
    SELECT
     DISTINCT ( ekbe~belnr ) AS document_number,
     ekbe~bwart AS movement_type,
     t156ht~btext AS movement_type_description,
     ekbe~vgabe AS transaction_type,
     ekbe~cpudt AS document_creation_date,
     ekbe~cputm AS document_creation_time

      FROM ekbe
      INNER JOIN @lt_po AS a ON a~document_number EQ ekbe~ebeln
      LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
      WHERE  ekbe~bwart IS NOT INITIAL
      INTO TABLE @DATA(lt_md).

    IF sy-subrc IS INITIAL AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "INVOICE
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

   FROM ekbe
   INNER JOIN @lt_po AS a ON a~document_number EQ ekbe~ebeln
   LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
   WHERE ekbe~bwart IS INITIAL
   INTO TABLE @DATA(lt_inv).

    IF sy-subrc IS INITIAL AND lt_inv IS NOT INITIAL.

      LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

        APPEND VALUE #( document_number              = <fs_inv>-document_number
                        document_category            = mm_document_category-inv
                        movement_type                = <fs_inv>-movement_type
                        movement_type_description    = <fs_inv>-movement_type_description
                        transaction_type             = <fs_inv>-transaction_type
                        document_creation_date       = <fs_inv>-document_creation_date
                        document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_rfq.

  ENDMETHOD.

  METHOD get_flow_from_qu.

  ENDMETHOD.

  METHOD get_flow_from_cn.

  ENDMETHOD.

  METHOD get_flow_from_sa.

  ENDMETHOD.

  METHOD get_flow_from_po.

    DATA(lt_vgabe_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'VGABE' ) )->get_ddic_fixed_values( sy-langu ).
    DATA(lt_bsart_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'BSART' ) )->get_ddic_fixed_values( sy-langu ).

    "Purchase Requisition
    SELECT
      DISTINCT ( eban~banfn )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time

      FROM ekpo
      INNER JOIN eban ON eban~banfn EQ ekpo~banfn
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ @me->type_of_document_change-insert
      WHERE ekpo~ebeln EQ @lv_document AND
            eban~bstyp EQ @me->purchasing_document_category-pr
      INTO TABLE @DATA(lt_pr).

    IF sy-subrc IS INITIAL AND lt_pr IS NOT INITIAL.

      LOOP AT lt_pr ASSIGNING FIELD-SYMBOL(<fs_pr>).
        APPEND VALUE #( document_number        = <fs_pr>-document_number
                        document_category      = mm_document_category-pr
                        document_creation_date = <fs_pr>-document_creation_date
                        document_creation_time = <fs_pr>-document_creation_time ) TO lt_mm_document_flow.
      ENDLOOP.

    ENDIF.

    "Outline agreement( Contract and Scheduling Agreement )
    SELECT
      DISTINCT ( ekpo~konnr )  AS document_number,
      cdhdr~udate AS document_creation_date,
      cdhdr~utime AS document_creation_time
    FROM ekpo
    INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
    WHERE ekpo~ebeln EQ @lv_document AND
          ekpo~konnr IS NOT INITIAL
    INTO TABLE @DATA(lt_oa).

    IF sy-subrc IS INITIAL AND lt_oa IS NOT INITIAL.

      LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<ls_oa>).

        SELECT SINGLE bstyp FROM ekko WHERE ebeln EQ @<ls_oa>-document_number INTO @DATA(lv_document_category).

        APPEND VALUE #( document_number      = <ls_oa>-document_number
                      document_category      = COND #( WHEN lv_document_category EQ me->purchasing_document_category-cn THEN mm_document_category-cn
                                                       WHEN lv_document_category EQ me->purchasing_document_category-sa THEN mm_document_category-sa
                                                       ELSE mm_document_category-cn )
                      document_creation_date = <ls_oa>-document_creation_date
                      document_creation_time = <ls_oa>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.



    ENDIF.

    "Purchase Order
    SELECT SINGLE
    ekko~ebeln  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
    WHERE ekpo~ebeln EQ @lv_document
    INTO @DATA(ls_po).

    IF sy-subrc IS INITIAL AND ls_po IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_po-document_number
                      document_category      = mm_document_category-po
                      document_creation_date = ls_po-document_creation_date
                      document_creation_time = ls_po-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Material Document
    SELECT
     DISTINCT ( ekbe~belnr ) AS document_number,
     ekbe~bwart AS movement_type,
     t156ht~btext AS movement_type_description,
     ekbe~vgabe AS transaction_type,
     a~ddtext AS transaction_type_description,
     ekbe~cpudt AS document_creation_date,
     ekbe~cputm AS document_creation_time

      FROM ekbe
      LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
      LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
      WHERE ebeln EQ @lv_document AND
            ekbe~bwart IS NOT INITIAL
      INTO TABLE @DATA(lt_md).

    IF sy-subrc IS INITIAL AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        transaction_type_description = <fs_md>-transaction_type_description
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "INVOICE
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    a~ddtext AS transaction_type_description,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

   FROM ekbe
   LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
   LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
   WHERE ebeln EQ @lv_document AND
         ekbe~bwart IS INITIAL
   INTO TABLE @DATA(lt_inv).

    IF sy-subrc IS INITIAL AND lt_inv IS NOT INITIAL.

      LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

        APPEND VALUE #( document_number              = <fs_inv>-document_number
                        document_category            = mm_document_category-inv
                        movement_type                = <fs_inv>-movement_type
                        movement_type_description    = <fs_inv>-movement_type_description
                        transaction_type             = <fs_inv>-transaction_type
                        transaction_type_description = <fs_inv>-transaction_type_description
                        document_creation_date       = <fs_inv>-document_creation_date
                        document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_md.

    DATA(lt_vgabe_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'VGABE' ) )->get_ddic_fixed_values( sy-langu ).
    DATA(lt_bsart_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'BSART' ) )->get_ddic_fixed_values( sy-langu ).

    "Purchase Order
    SELECT SINGLE
    ekko~ebeln  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN mseg ON mseg~ebeln EQ ekko~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
    WHERE mseg~mblnr EQ @lv_document
    INTO @DATA(ls_po).

    IF sy-subrc IS INITIAL AND ls_po IS NOT INITIAL.
      APPEND VALUE #( document_number        = ls_po-document_number
                      document_category      = mm_document_category-po
                      document_creation_date = ls_po-document_creation_date
                      document_creation_time = ls_po-document_creation_time ) TO lt_mm_document_flow.
    ENDIF.

    "Purchase Requisition
    IF ls_po IS NOT INITIAL.

      SELECT
        DISTINCT ( eban~banfn )  AS document_number,
        cdhdr~udate AS document_creation_date,
        cdhdr~utime AS document_creation_time

        FROM ekpo
        INNER JOIN eban ON eban~banfn EQ ekpo~banfn
        LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ eban~banfn AND cdhdr~change_ind EQ @me->type_of_document_change-insert
        WHERE ekpo~ebeln EQ @ls_po-document_number AND
              eban~bstyp EQ @me->purchasing_document_category-pr
        INTO TABLE @DATA(lt_pr).

      IF sy-subrc IS INITIAL AND lt_pr IS NOT INITIAL.

        LOOP AT lt_pr ASSIGNING FIELD-SYMBOL(<fs_pr>).
          APPEND VALUE #( document_number        = <fs_pr>-document_number
                          document_category      = mm_document_category-pr
                          document_creation_date = <fs_pr>-document_creation_date
                          document_creation_time = <fs_pr>-document_creation_time ) TO lt_mm_document_flow.
        ENDLOOP.

      ENDIF.

    ENDIF.

    "Outline agreement( Contract and Scheduling Agreement )
    IF ls_po IS NOT INITIAL.

      SELECT
        DISTINCT ( ekpo~konnr )  AS document_number,
        cdhdr~udate AS document_creation_date,
        cdhdr~utime AS document_creation_time
      FROM ekpo
      INNER JOIN ekko ON ekko~ebeln EQ ekpo~ebeln
      LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
      WHERE ekpo~ebeln EQ @ls_po-document_number AND
            ekpo~konnr IS NOT INITIAL
      INTO TABLE @DATA(lt_oa).

      IF sy-subrc IS INITIAL AND lt_oa IS NOT INITIAL.

        LOOP AT lt_oa ASSIGNING FIELD-SYMBOL(<ls_oa>).

          SELECT SINGLE bstyp FROM ekko WHERE ebeln EQ @<ls_oa>-document_number INTO @DATA(lv_document_category).

          APPEND VALUE #( document_number      = <ls_oa>-document_number
                        document_category      = COND #( WHEN lv_document_category EQ me->purchasing_document_category-cn THEN mm_document_category-cn
                                                         WHEN lv_document_category EQ me->purchasing_document_category-sa THEN mm_document_category-sa
                                                         ELSE mm_document_category-cn )
                        document_creation_date = <ls_oa>-document_creation_date
                        document_creation_time = <ls_oa>-document_creation_time ) TO lt_mm_document_flow.

        ENDLOOP.

      ENDIF.

    ENDIF.

    "Material Document
    SELECT
    DISTINCT ( ekbe~belnr ) AS document_number,
    ekbe~bwart AS movement_type,
    t156ht~btext AS movement_type_description,
    ekbe~vgabe AS transaction_type,
    a~ddtext AS transaction_type_description,
    ekbe~cpudt AS document_creation_date,
    ekbe~cputm AS document_creation_time

     FROM ekbe
     LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
     LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
     WHERE belnr EQ @lv_document AND
           ekbe~bwart IS NOT INITIAL
     INTO TABLE @DATA(lt_md).

    IF sy-subrc IS INITIAL AND lt_md IS NOT INITIAL.

      LOOP AT lt_md ASSIGNING FIELD-SYMBOL(<fs_md>).

        APPEND VALUE #( document_number              = <fs_md>-document_number
                        document_category            = mm_document_category-md
                        movement_type                = <fs_md>-movement_type
                        movement_type_description    = <fs_md>-movement_type_description
                        transaction_type             = <fs_md>-transaction_type
                        transaction_type_description = <fs_md>-transaction_type_description
                        document_creation_date       = <fs_md>-document_creation_date
                        document_creation_time       = <fs_md>-document_creation_time ) TO lt_mm_document_flow.

      ENDLOOP.

    ENDIF.

    "Invoice
    IF ls_po IS NOT INITIAL.

      SELECT
      DISTINCT ( ekbe~belnr ) AS document_number,
      ekbe~bwart AS movement_type,
      t156ht~btext AS movement_type_description,
      ekbe~vgabe AS transaction_type,
      a~ddtext AS transaction_type_description,
      ekbe~cpudt AS document_creation_date,
      ekbe~cputm AS document_creation_time

     FROM ekbe
     LEFT OUTER JOIN t156ht ON ekbe~bwart EQ t156ht~bwart AND t156ht~spras EQ @sy-langu
     LEFT OUTER JOIN @lt_vgabe_domain_values AS a ON a~low EQ ekbe~vgabe ##ITAB_KEY_IN_SELECT
     WHERE ebeln EQ @ls_po-document_number AND
           ekbe~bwart IS INITIAL
     INTO TABLE @DATA(lt_inv).

      IF sy-subrc IS INITIAL AND lt_inv IS NOT INITIAL.

        LOOP AT lt_inv ASSIGNING FIELD-SYMBOL(<fs_inv>).

          APPEND VALUE #( document_number              = <fs_inv>-document_number
                          document_category            = mm_document_category-inv
                          movement_type                = <fs_inv>-movement_type
                          movement_type_description    = <fs_inv>-movement_type_description
                          transaction_type             = <fs_inv>-transaction_type
                          transaction_type_description = <fs_inv>-transaction_type_description
                          document_creation_date       = <fs_inv>-document_creation_date
                          document_creation_time       = <fs_inv>-document_creation_time ) TO lt_mm_document_flow.

        ENDLOOP.

      ENDIF.

    ENDIF.


  ENDMETHOD.

  METHOD get_flow_from_inv.

    DATA(lt_vgabe_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'VGABE' ) )->get_ddic_fixed_values( sy-langu ).
    DATA(lt_bsart_domain_values) =  CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_name( 'BSART' ) )->get_ddic_fixed_values( sy-langu ).

    "Purchase Order
    SELECT
    ekko~ebeln  AS document_number,
    cdhdr~udate AS document_creation_date,
    cdhdr~utime AS document_creation_time

    FROM ekko
    INNER JOIN ekpo ON ekko~ebeln EQ ekpo~ebeln
    INNER JOIN ekbe ON ekbe~ebeln EQ ekko~ebeln
    LEFT OUTER JOIN cdhdr ON cdhdr~objectid EQ ekko~ebeln AND cdhdr~change_ind EQ @me->type_of_document_change-insert
    WHERE ekbe~belnr EQ @lv_document
    INTO TABLE @DATA(lt_po).

    IF sy-subrc IS INITIAL AND lt_po IS NOT INITIAL.

      LOOP AT lt_po ASSIGNING FIELD-SYMBOL(<fs>).
        APPEND VALUE #( document_number        = <fs>-document_number
                        document_category      = mm_document_category-po
                        document_creation_date = <fs>-document_creation_date
                        document_creation_time = <fs>-document_creation_time ) TO lt_mm_document_flow.
      ENDLOOP.

    ENDIF.

  ENDMETHOD.

  METHOD get_flow_from_ac.

    "INVOICE


    "MATERIAL DOCUMENT



  ENDMETHOD.

  METHOD build_node_table.

    "ROOT NODE
    APPEND VALUE #( hidden    = space
                    disabled  = space
                    isfolder  = abap_true
                    node_key  = |Root Node|
                    text      = |Document Flow { VALUE #( lt_mm_document_flow[ document_number = lv_document ]-document_category OPTIONAL ) } { lv_document ALPHA = OUT }|
                    n_image   = icon_system_favorites
                    exp_image = icon_system_favorites ) TO lt_tree_nodes.

    SORT lt_mm_document_flow STABLE BY transaction_type ASCENDING.

    "Construct Nodes Table with Scenario Nodes
    LOOP AT lt_mm_document_flow ASSIGNING FIELD-SYMBOL(<fs_mm_document_flow>) GROUP BY <fs_mm_document_flow>-document_category.

      APPEND VALUE #( hidden    = space
                      disabled  = space
                      isfolder  = abap_true
                      relatkey  = VALUE #( lt_tree_nodes[ 1 ]-node_key OPTIONAL )
                      relatship = cl_gui_simple_tree=>relat_last_child
                      node_key  = <fs_mm_document_flow>-document_category
                      text      = VALUE #( lt_document_category_descr[ document_category = <fs_mm_document_flow>-document_category  ]-document_category_descr DEFAULT 'Undefined' )
                      expander  = abap_true
                      n_image   = icon_biw_formula
                      exp_image = icon_biw_formula ) TO lt_tree_nodes.

      LOOP AT GROUP <fs_mm_document_flow> ASSIGNING FIELD-SYMBOL(<fs_group_line>).

        APPEND VALUE #( hidden    = space
                        disabled  = space
                        isfolder  = space
                        relatkey  = <fs_group_line>-document_category
                        relatship = cl_gui_simple_tree=>relat_last_child
                        node_key  = |{ <fs_group_line>-document_number ALPHA = OUT } |
                        text      = CONV #( |{ <fs_group_line>-document_number ALPHA = OUT }| )
                        expander  = space
                        n_image   = icon_patient_smartcard
                        exp_image = icon_patient_smartcard ) TO lt_tree_nodes.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.

  METHOD create_containers.

    IF me->lr_splitter_container IS NOT BOUND.

      CLEAR:me->lr_splitter_container,me->lr_left_container,me->lr_right_container.

      me->lr_splitter_container = NEW #( parent = NEW cl_gui_custom_container( container_name = me->lv_screen_container )
                                                      no_autodef_progid_dynnr = abap_true
                                                      rows    = 1
                                                      columns = 2 ).

      me->lr_splitter_container->set_column_width( id = 1 width = 15 ).
      me->lr_left_container  = me->lr_splitter_container->get_container( row = 1 column = 1 ).
      me->lr_right_container = me->lr_splitter_container->get_container( row = 1 column = 2 ).

    ENDIF.

  ENDMETHOD.

  METHOD create_tree.

    IF lo_tree IS NOT BOUND.

      "CREATE TREE OBJECT
      lo_tree = NEW #( parent              = me->lr_left_container
                       node_selection_mode = cl_gui_simple_tree=>node_sel_mode_single ).

      IF lo_tree IS NOT BOUND.
        RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Error Creating Tree'.
      ENDIF.

      "REGISTER EVENTS
      lo_tree->set_registered_events( EXPORTING events = VALUE #( ( eventid = cl_gui_simple_tree=>eventid_node_double_click appl_event = space ) )
                                      EXCEPTIONS cntl_error                = 1
                                                 cntl_system_error         = 2
                                                 illegal_event_combination = 3 ).
      IF sy-subrc IS NOT INITIAL.
        RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Error Creating Tree'.
      ENDIF.

      SET HANDLER me->handle_node_double_click FOR lo_tree.

      "ADD NODES TO TREE
      lo_tree->add_nodes(
        EXPORTING
          table_structure_name           = CONV #( CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( lt_tree_nodes[ 1 ] ) )->absolute_name+6 )
          node_table                     = lt_tree_nodes
        EXCEPTIONS
          error_in_node_table            = 1
          failed                         = 2
          dp_error                       = 3
          table_structure_name_not_found = 4
          OTHERS                         = 5 ).

      IF sy-subrc IS NOT INITIAL.
        RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Error Creating Tree'.
      ENDIF.

      "EXPAND NODES
      lo_tree->expand_root_nodes(
        EXPORTING
          level_count       = 3
          expand_subtree    = abap_true
      EXCEPTIONS
        failed              = 1
        illegal_level_count = 2
        cntl_system_error   = 3
        OTHERS              = 4 ).

      IF sy-subrc IS NOT INITIAL.
        RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Error Creating Tree'.
      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD handle_node_double_click.

    me->reset_tree_selection( ).

    "MARK LINE SELECTED
    lo_tree->node_set_style( EXPORTING node_key = VALUE #( lt_tree_nodes[ node_key = node_key ]-node_key OPTIONAL )
                                       style    = cl_gui_simple_tree=>style_emphasized_positive
                             EXCEPTIONS failed            = 1
                                        node_not_found    = 2
                                        cntl_system_error = 3 ).

    "CALL ALV HEADER-ITEM FOR PURCHASING DOCUMENT
    DATA(ls_selection_data) = VALUE #( lt_tree_nodes[ node_key = node_key ] OPTIONAL ).
    IF ls_selection_data-isfolder IS INITIAL AND ls_selection_data-node_key IS NOT INITIAL.
      me->display_document_details( im_document      = CONV #( |{ ls_selection_data-node_key ALPHA = IN }| )
                                    im_document_cat  = CONV #( ls_selection_data-relatkey )
                                    im_document_year = CONV #( VALUE #( me->lt_mm_document_flow[ document_number = ls_selection_data-node_key ]-document_creation_date+0(4) OPTIONAL ) ) ).
    ENDIF.

    "REFRESH DATA
    cl_gui_cfw=>set_new_ok_code( new_code = 'FOO' ).

  ENDMETHOD.

  METHOD display_document_details.

    CLEAR:lr_details_table.
    lr_details_table = me->get_details_table( EXPORTING im_document      = CONV #( |{ im_document ALPHA = IN }| ) ##OPERATOR[EBELN]
                                                        im_document_cat  = CONV #( im_document_cat )
                                                        im_document_year = COND #( WHEN im_document_year IS NOT INITIAL THEN im_document_year ) ) ##OPERATOR[TY_ENUM_MM_DOCUMENT_CATEGORY] .

    ASSIGN lr_details_table->* TO FIELD-SYMBOL(<fs_table>).

    CHECK <fs_table> IS ASSIGNED.

    IF lo_alv_details IS BOUND.
      me->lo_alv_details->free( ).
      CLEAR:me->lo_alv_details.
    ENDIF.

    "ALV Object Instantiation
    me->lo_alv_details = NEW #( i_parent = me->lr_right_container ).

    "AUTOMATIC CREATION OF FIELD CATALOG BASED ON INTERNAL TABLE
    TRY.
        cl_salv_table=>factory( IMPORTING r_salv_table = DATA(salv_table) CHANGING t_table = <fs_table> ).
        DATA(lt_fieldcat) = cl_salv_controller_metadata=>get_lvc_fieldcatalog( r_columns = salv_table->get_columns( ) r_aggregations = salv_table->get_aggregations( ) ).
      CATCH cx_salv_msg.
        RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Error Loading the Field Catalog'.
    ENDTRY.

    "Field Catalog Modifications
    LOOP AT lt_fieldcat ASSIGNING FIELD-SYMBOL(<fs_fieldcat>).

      <fs_fieldcat>-just = 'C'.

      CASE <fs_fieldcat>-fieldname.
        WHEN 'MANDT'.
          <fs_fieldcat>-no_out = abap_true.
        WHEN 'MATNR' OR 'EBELN' OR 'BANFN' OR 'MBLNR' OR 'BELNR'.
          <fs_fieldcat>-hotspot = abap_true.
        WHEN OTHERS.

      ENDCASE.

    ENDLOOP.

    "Event Handling
    SET HANDLER: me->handle_hotspot_click FOR lo_alv_details,
                 me->toolbar              FOR lo_alv_details,
                 me->user_command         FOR lo_alv_details.

    "Register the event to trigger DATA_CHANGED event when modify or press enter.
    lo_alv_details->register_edit_event( i_event_id = cl_gui_alv_grid=>mc_evt_enter ).
    lo_alv_details->register_edit_event( i_event_id = cl_gui_alv_grid=>mc_evt_modified ).

    lo_alv_details->set_table_for_first_display(
      EXPORTING
        i_save                        = cl_dba_core_constants=>co_save_layout_by_user
        is_variant                    = VALUE disvariant( report = sy-repid
                                                          username = sy-uname )
        is_layout                     = VALUE lvc_s_layo( zebra = abap_true
                                                          cwidth_opt = abap_true
                                                          grid_title = | { VALUE #( me->lt_document_category_descr[ document_category = im_document_cat ]-document_category_descr OPTIONAL ) } { im_document ALPHA = OUT } Item Details |  )
        it_toolbar_excluding          = VALUE ui_functions( ( cl_gui_alv_grid=>mc_fc_loc_insert_row )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_copy_row )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_append_row )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_undo )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_delete_row )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_copy )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_cut )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_paste_new_row )
                                                            ( cl_gui_alv_grid=>mc_fc_loc_paste ) )
      CHANGING
        it_outtab                     = <fs_table>
        it_fieldcatalog               = lt_fieldcat
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        OTHERS                        = 4 ).

    IF sy-subrc IS NOT INITIAL.
      RAISE EXCEPTION TYPE lcx_exception EXPORTING im_text = 'Error Loading the ALV'.
    ENDIF.

    "Set Ready for input for Style.
    lo_alv_details->set_ready_for_input( i_ready_for_input = 1 ).

*    lo_alv_details->refresh_table_display( is_stable = VALUE lvc_s_stbl( row = abap_true col = abap_true ) ).

  ENDMETHOD.

  METHOD get_details_table.

    CASE im_document_cat.

      WHEN me->mm_document_category-pr.

        SELECT FROM eban
          FIELDS eban~*
          WHERE eban~banfn EQ @im_document
          ORDER BY bnfpo ASCENDING
          INTO TABLE @DATA(t_table_pr).

        "Copy Table to heap memory
        DATA(lo_tabledesc) = CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( p_data = t_table_pr ) ).

        "Create table in heap memory and set return reference
        CREATE DATA re_table TYPE HANDLE lo_tabledesc.

        FIELD-SYMBOLS <lt_pr> LIKE t_table_pr.
        ASSIGN re_table->* TO <lt_pr>.
        APPEND LINES OF t_table_pr TO <lt_pr>.

      WHEN me->mm_document_category-po OR me->mm_document_category-qu OR me->mm_document_category-rfq OR me->mm_document_category-sa OR  me->mm_document_category-cn .

        SELECT FROM ekpo
          FIELDS ekpo~*
          WHERE ekpo~ebeln EQ @im_document
          ORDER BY ebelp ASCENDING
          INTO TABLE @DATA(t_table_po).

        "Copy Table to heap memory
        lo_tabledesc = CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( p_data = t_table_po ) ).

        "Create table in heap memory and set return reference
        CREATE DATA re_table TYPE HANDLE lo_tabledesc.

        FIELD-SYMBOLS <lt_po> LIKE t_table_po.
        ASSIGN re_table->* TO <lt_po>.
        APPEND LINES OF t_table_po TO <lt_po>.

      WHEN me->mm_document_category-md.

        SELECT FROM mseg
          FIELDS mseg~*
          WHERE mseg~mblnr EQ @im_document AND
                mseg~mjahr EQ @im_document_year
          ORDER BY zeile ASCENDING
          INTO TABLE @DATA(t_table_md).

        "Copy Table to heap memory
        lo_tabledesc = CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( p_data = t_table_md ) ).

        "Create table in heap memory and set return reference
        CREATE DATA re_table TYPE HANDLE lo_tabledesc.

        FIELD-SYMBOLS <lt_md> LIKE t_table_md.
        ASSIGN re_table->* TO <lt_md>.
        APPEND LINES OF t_table_md TO <lt_md>.

      WHEN me->mm_document_category-inv.

        SELECT FROM rseg
            FIELDS rseg~*
            WHERE rseg~belnr EQ @im_document AND
                  rseg~gjahr EQ @im_document_year
            ORDER BY buzei ASCENDING
            INTO TABLE @DATA(t_table_inv).

        "Copy Table to heap memory
        lo_tabledesc = CAST cl_abap_tabledescr( cl_abap_tabledescr=>describe_by_data( p_data = t_table_inv ) ).

        "Create table in heap memory and set return reference
        CREATE DATA re_table TYPE HANDLE lo_tabledesc.

        FIELD-SYMBOLS <lt_inv> LIKE t_table_inv.
        ASSIGN re_table->* TO <lt_inv>.
        APPEND LINES OF t_table_inv TO <lt_inv>.

    ENDCASE.

  ENDMETHOD.

  METHOD toolbar.

    "APPEND VALUE #( function = 'ZFC1' text  = 'Process Selected Lines' icon = icon_operation ) TO e_object->mt_toolbar.

  ENDMETHOD.

  METHOD user_command.

    CASE e_ucomm.

      WHEN OTHERS.

    ENDCASE.

  ENDMETHOD.

  METHOD handle_hotspot_click.

    FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.

    ASSIGN lr_details_table->* TO <fs_table>.
    ASSIGN COMPONENT e_column_id OF STRUCTURE <fs_table>[ es_row_no-row_id ] TO FIELD-SYMBOL(<fs_value>).

    CHECK <fs_value> IS ASSIGNED AND <fs_value> IS NOT INITIAL.

    CASE e_column_id.

      WHEN 'BANFN'.

        SET PARAMETER ID 'BAN' FIELD <fs_value>.
        CALL TRANSACTION 'ME53N' WITH AUTHORITY-CHECK.

      WHEN 'MATNR'.

        SET PARAMETER ID 'MAT' FIELD <fs_value>.
        CALL TRANSACTION 'MM03' WITH AUTHORITY-CHECK AND SKIP FIRST SCREEN.

      WHEN 'EBELN'.

        SET PARAMETER ID 'BES' FIELD <fs_value>.
        CALL TRANSACTION 'ME23N' WITH AUTHORITY-CHECK AND SKIP FIRST SCREEN.

      WHEN 'MBLNR'.

        SET PARAMETER ID 'MBN' FIELD <fs_value>.
        CALL TRANSACTION 'MIGO' WITH AUTHORITY-CHECK AND SKIP FIRST SCREEN.

      WHEN 'BELNR'.

*        SET PARAMETER ID 'BLN' FIELD <fs_value>.
*        CALL TRANSACTION 'FB03' WITH AUTHORITY-CHECK AND SKIP FIRST SCREEN.

      WHEN OTHERS.

    ENDCASE.

  ENDMETHOD.

  METHOD reset_tree_selection.

    "RESET SELECTION STYLE
    LOOP AT lt_tree_nodes ASSIGNING FIELD-SYMBOL(<fs_node>).

      lo_tree->node_set_style(
        EXPORTING
          node_key          = <fs_node>-node_key
          style             = cl_gui_simple_tree=>style_default
        EXCEPTIONS
           failed            = 1
           node_not_found    = 2
           cntl_system_error = 3 ).

    ENDLOOP.

  ENDMETHOD.

ENDCLASS.

*&----------------------------------------------------------------------*
*&CLASS LCX_EXCEPTION IMPLEMENTATION
*&----------------------------------------------------------------------*
CLASS lcx_exception IMPLEMENTATION.

  METHOD constructor.

    super->constructor( textid = CONV #( im_textid )
                        previous = CONV #( im_previous ) ) ##OPERATOR[REFERENCE].

    mv_message = COND #( WHEN im_text IS SUPPLIED AND im_text IS NOT INITIAL THEN im_text ).

  ENDMETHOD.

  METHOD get_text.

    result = super->get_text( ).

    IF me->mv_message IS NOT INITIAL.
      result = COND #( WHEN result IS INITIAL THEN  me->mv_message
                       WHEN result IS NOT INITIAL THEN |{ result }-{ me->mv_message } | ).
    ENDIF.

  ENDMETHOD.

  METHOD get_longtext.

    result = super->get_longtext( ).

    IF me->mv_message IS NOT INITIAL.
      result = COND #( WHEN result IS INITIAL THEN  me->mv_message
                       WHEN result IS NOT INITIAL THEN |{ result }-{ me->mv_message } | ).
    ENDIF.

  ENDMETHOD.

ENDCLASS.

*&---------------------------------------------------------------------*
*& Module PROCESS_BEFORE_OUTPUT OUTPUT
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  lcl_mm_doc_flow=>get_instance( )->process_before_output( ).

ENDMODULE.
*&---------------------------------------------------------------------*
*&      Module  PAI_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.

  DATA:ok_code_0100 TYPE sy-ucomm.

  lcl_mm_doc_flow=>get_instance( )->process_after_input( EXPORTING screen_okcode = ok_code_0100 ).

  CLEAR:ok_code_0100.

ENDMODULE.
