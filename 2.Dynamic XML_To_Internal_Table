************************************************************************
*   Program name:                                                      *
*   Description :                                                      *
*                                                                      *
*   Created   by: GDRAKOS DVALOUXIS                                    *
*                                                                      *
************************************************************************
REPORT xml_to_internal_table.

TYPES:BEGIN OF t_xml_table,
        value_node1 TYPE c LENGTH 50,
        value_node2 TYPE c LENGTH 50,
        value_node3 TYPE c LENGTH 50,
        value_node4 TYPE c LENGTH 50,
        value_node5 TYPE c LENGTH 50,
        value_node6 TYPE c LENGTH 50,
      END OF t_xml_table.

DATA:gt_data TYPE STANDARD TABLE OF t_xml_table WITH EMPTY KEY INITIAL SIZE 0.

CLASS lcx_xml DEFINITION INHERITING FROM cx_static_check.

  PUBLIC SECTION.

    METHODS: constructor IMPORTING text TYPE string,
      get_text REDEFINITION.

  PRIVATE SECTION.

    DATA: local_text TYPE string.

ENDCLASS.

CLASS lcx_xml IMPLEMENTATION.

  METHOD constructor.

    super->constructor( textid = CONV #( text ) ).
    local_text = text.

  ENDMETHOD.

  METHOD get_text.

    result = me->local_text.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_xml DEFINITION CREATE PUBLIC.

  PUBLIC SECTION.

    CLASS-METHODS:

      open_dialog RETURNING VALUE(re_filepath)  TYPE file_table-filename,

      display_table IMPORTING im_table           TYPE ANY TABLE
                              im_technical_names TYPE abap_bool DEFAULT abap_false.

    METHODS:

      read_xml IMPORTING im_filepath  TYPE file_table-filename
               EXPORTING ex_xml_table TYPE hrpayfr_t_smum_xmltb
               RAISING   lcx_xml,

      get_structured_table_from_xml IMPORTING im_xml_table      TYPE hrpayfr_t_smum_xmltb
                                              im_attribute_node TYPE cname OPTIONAL
                                              im_map_by_index   TYPE abap_bool DEFAULT abap_false
                                    EXPORTING ex_table          TYPE ANY TABLE
                                    RAISING   lcx_xml.

ENDCLASS.

CLASS lcl_xml IMPLEMENTATION.

  METHOD open_dialog.

    DATA:   lt_file_table TYPE filetable,
            lv_return     TYPE i.

    CLEAR:lt_file_table.
    CALL METHOD cl_gui_frontend_services=>file_open_dialog
      EXPORTING
        window_title            = 'File System of Presentation Server'
        default_extension       = cl_gui_frontend_services=>filetype_xml
        file_filter             = 'All Files(*.*)|*.*|' && 'XML Files (*.xml)|*.xml|'
      CHANGING
        file_table              = lt_file_table
        rc                      = lv_return
      EXCEPTIONS
        file_open_dialog_failed = 1
        cntl_error              = 2
        error_no_gui            = 3
        OTHERS                  = 4.

    CHECK sy-subrc IS INITIAL.

    TRY.
        re_filepath =  lt_file_table[ 1 ]-filename.
      CATCH cx_sy_itab_line_not_found.
        CLEAR:re_filepath.
    ENDTRY.

  ENDMETHOD.

  METHOD read_xml.

    DATA: lt_return      TYPE TABLE OF bapiret2.

    DATA(lo_xml) = NEW cl_xml_document( ).

    CALL METHOD lo_xml->import_from_file
      EXPORTING
        filename = CONV #( im_filepath )
      RECEIVING
        retcode  = DATA(lv_subrc).

    IF lv_subrc EQ 0.

      CALL METHOD lo_xml->render_2_xstring
        IMPORTING
          retcode = lv_subrc
          stream  = DATA(lv_xml_xstring)
          size    = DATA(lv_size).

      IF lv_subrc EQ 0.

        CLEAR:lt_return.
        CALL FUNCTION 'SMUM_XML_PARSE'
          EXPORTING
            xml_input = lv_xml_xstring
          TABLES
            xml_table = ex_xml_table
            return    = lt_return.

      ENDIF.

    ENDIF.

    IF sy-subrc NE 0 OR
       line_exists( lt_return[ type = 'E' ] ) OR
       line_exists( lt_return[ type = 'A' ] ) OR
       line_exists( lt_return[ type = 'X' ] ).

      RAISE EXCEPTION TYPE lcx_xml EXPORTING text = 'Error Parsing the XML File'.

    ENDIF.

  ENDMETHOD.

  METHOD get_structured_table_from_xml.

    "CHEATSHEET: "Hier would hold the value ‘1’ for the element in the root node,‘Hier’ would hold the value ‘2’ for the fields in the Element node
    "Type holds for all the elements in the Header of the XML file would be ‘A’(attributes). It would be ‘V’(values) for the value nodes.For all the other nodes, it would hold a blank.
    "Cname contains the names of the nodes.
    "Cvalue contains the values held by the elements of the various nodes of an XML file

    DATA: ref_wa          TYPE REF TO data,
          lv_line_counter TYPE sy-tabix.

    FIELD-SYMBOLS: <fs_itab>  TYPE ANY TABLE,
                   <fs_wa>    TYPE any,
                   <fs_value> TYPE any.

    "CHECK IMPORTING TABLE IS NOT INITIAL
    CHECK im_xml_table IS NOT INITIAL.

    "CREATE A DYNAMIC TABLE WITH THE SAME STRUCTURE AS TARGETED TABLE
    ASSIGN ex_table  TO <fs_itab>.

    "DATA REFERENCE
    CREATE DATA ref_wa LIKE LINE OF <fs_itab>.
    ASSIGN ref_wa->* TO <fs_wa>.

    LOOP AT im_xml_table ASSIGNING FIELD-SYMBOL(<fs_xml_line>).

      DATA(lv_tabix) = sy-tabix.

      "MAP BY SUPPLIED ATTRIBUTE NODE
      IF im_attribute_node IS NOT INITIAL.

        IF <fs_xml_line>-cname EQ im_attribute_node.

          CLEAR:lv_line_counter.
          DO.
            lv_line_counter = lv_line_counter + 1.
            READ TABLE im_xml_table INDEX lv_tabix + lv_line_counter INTO DATA(ls_xml_table).
            IF sy-subrc EQ 0 AND
               ls_xml_table-cname NE im_attribute_node AND
               ls_xml_table-type EQ 'V' .

              IF im_map_by_index EQ abap_true.
                ASSIGN COMPONENT lv_line_counter OF STRUCTURE <fs_wa> TO  <fs_value>.
              ELSE.
                ASSIGN COMPONENT ls_xml_table-cname OF STRUCTURE <fs_wa> TO  <fs_value>.
              ENDIF.

              IF <fs_value> IS ASSIGNED.
                <fs_value> = ls_xml_table-cvalue.
              ENDIF.

            ELSE.

              IF <fs_wa> IS NOT INITIAL.
                INSERT <fs_wa> INTO TABLE ex_table.
              ENDIF.

              CLEAR:<fs_wa>.
              EXIT.
            ENDIF.


          ENDDO.

        ENDIF.

      ELSE.

        IF <fs_xml_line>-type EQ 'A'.

          CLEAR:lv_line_counter.
          DO.
            lv_line_counter = lv_line_counter + 1.
            READ TABLE im_xml_table INDEX lv_tabix + lv_line_counter INTO ls_xml_table.
            IF sy-subrc EQ 0 AND
               ls_xml_table-type EQ 'V'.

              IF im_map_by_index EQ abap_true.
                ASSIGN COMPONENT lv_line_counter OF STRUCTURE <fs_wa> TO  <fs_value>.
              ELSE.
                ASSIGN COMPONENT ls_xml_table-cname OF STRUCTURE <fs_wa> TO  <fs_value>.
              ENDIF.

              IF <fs_value> IS ASSIGNED.
                <fs_value> = ls_xml_table-cvalue.
              ENDIF.

            ELSE.

              IF <fs_wa> IS NOT INITIAL.
                INSERT <fs_wa> INTO TABLE ex_table.
              ENDIF.

              CLEAR:<fs_wa>.
              EXIT.

            ENDIF.

          ENDDO.

        ENDIF.

      ENDIF.

    ENDLOOP.


  ENDMETHOD.

  METHOD display_table.

    DATA:ref_wa TYPE REF TO data.

    CREATE DATA ref_wa LIKE im_table.

    ASSIGN ref_wa->* TO  FIELD-SYMBOL(<fs_itab>).
    <fs_itab> = im_table.

    TRY.
        cl_salv_table=>factory( IMPORTING r_salv_table = DATA(alv) CHANGING t_table = <fs_itab> ).
      CATCH cx_salv_msg.
    ENDTRY.

    "Columns Optimize
    alv->get_columns( )->set_optimize( if_salv_c_bool_sap=>true ).

    "Build Field Catalog Dynamically in Case of Empty
    LOOP AT alv->get_columns( )->get( ) ASSIGNING FIELD-SYMBOL(<fs_cols>).

      IF <fs_cols>-r_column->get_medium_text( ) IS INITIAL.
        <fs_cols>-r_column->set_medium_text( CONV #( <fs_cols>-columnname ) ).
      ENDIF.

    ENDLOOP.

    " Show technical and regular column names at the same time as column names
    IF im_technical_names EQ abap_true.
      LOOP AT alv->get_columns( )->get( ) ASSIGNING FIELD-SYMBOL(<c>).
        <c>-r_column->set_short_text( |{ <c>-r_column->get_columnname( ) } [{ <c>-r_column->get_short_text( ) }]| ).
        <c>-r_column->set_medium_text( |{ <c>-r_column->get_columnname( ) } [{ <c>-r_column->get_medium_text( ) }]| ).
        <c>-r_column->set_long_text( |{ <c>-r_column->get_columnname( ) } [{ <c>-r_column->get_long_text( ) }]| ).
      ENDLOOP.
    ENDIF.

    "Stripped Display
    alv->get_display_settings( )->set_striped_pattern( if_salv_c_bool_sap=>true ).

    "Full Toolbar Options
    alv->get_functions( )->set_all( ).

    " Enable Multiple Selection in the ALV Layout and Enable Left Column for Selection
    alv->get_selections( )->set_selection_mode( if_salv_c_selection_mode=>row_column )."cl_salv_selections=>multiple

    "Layout Settings
    DATA(v_key) = VALUE salv_s_layout_key( report = sy-repid ).
    alv->get_layout( )->set_key( value = v_key ).
    alv->get_layout( )->set_default( abap_true ).
    alv->get_layout( )->set_save_restriction( if_salv_c_layout=>restrict_none ).
    alv->get_layout( )->set_default( if_salv_c_bool_sap=>true ).

    alv->display( ).

  ENDMETHOD.

ENDCLASS.

*&---------------------------------------------------------------------*
*& SELECTION SCREEN DESIGN
*&---------------------------------------------------------------------*
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE title1.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_file FOR FIELD p_file.
PARAMETERS: p_file TYPE file_table-filename.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_attr FOR FIELD p_attr.
PARAMETERS: p_attr TYPE cname.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN COMMENT 1(26) t_index FOR FIELD p_index.
PARAMETERS: p_index AS CHECKBOX DEFAULT ''.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK b1.
*&---------------------------------------------------------------------*
*& INITIALIZATION OF SELECTION SCREEN ELEMENTS
*&---------------------------------------------------------------------*
INITIALIZATION.
  PERFORM screen_initialization.
*&---------------------------------------------------------------------*
*& AT SELECTION SCREEN ON VALUE REQUESTS (F4)
*&---------------------------------------------------------------------*
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.
  p_file =  lcl_xml=>open_dialog( ).
*&---------------------------------------------------------------------*
*& EXECUTABLE CODE
*&---------------------------------------------------------------------*
START-OF-SELECTION.

  DATA(lo_xml) = NEW lcl_xml( ).

  TRY.
      lo_xml->read_xml(
        EXPORTING
          im_filepath  = p_file
        IMPORTING
          ex_xml_table = DATA(lt_xml) ).

      lo_xml->get_structured_table_from_xml(
        EXPORTING
          im_xml_table = lt_xml
          im_attribute_node = p_attr
          im_map_by_index = p_index
        IMPORTING
          ex_table = gt_data ).

      CALL METHOD lcl_xml=>display_table( EXPORTING im_table = gt_data ).

    CATCH lcx_xml INTO DATA(lo_exception).
      MESSAGE lo_exception->get_text( ) TYPE 'I' DISPLAY LIKE 'E'.
  ENDTRY.

END-OF-SELECTION.

*&---------------------------------------------------------------------*
*& SUBROUTINE CREATION
*&---------------------------------------------------------------------*

*&---------------------------------------------------------------------*
*& Form SCREEN INITIALIZATION
*&---------------------------------------------------------------------*
FORM screen_initialization.

  title1  = 'XML'.

  t_file  = 'XML Filepath'.
  t_attr  = 'Attribute Node'.
  t_index = 'Map by Index'.

ENDFORM.
